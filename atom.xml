<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Zen]]></title>
  <subtitle><![CDATA[craft‘s note]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-21T13:49:31.154Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[crafteverywhere]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Emacs入门笔记]]></title>
    <link href="http://yoursite.com/2016/02/21/Emacs%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/02/21/Emacs个人笔记/</id>
    <published>2016-02-21T13:49:31.190Z</published>
    <updated>2016-02-21T13:49:31.154Z</updated>
    <content type="html"><![CDATA[<p>春节前开始正式地系统学习 emacs, 目前已经基本上能够做到正常使用了.<br>这篇文章并不是一篇有效的 emacs 教程, 主要用来记录学习过程中的一些心得.</p>
<p>接触 Emacs 之前以使用 vim/sublime 为主. 在这次学习之前, 对Emacs所知甚少, 唯一印象深刻的命令是如何关掉它: <code>C-x C-c</code>, 算是非常彻底的从零开始.<br>这里先简单介绍一点有关 emacs 的基本常识.<br>Vim 和 emacs 都属于尽可能发挥键盘威力的文本编辑器: 但不同之处在于, vim 选择区分不同的模式分别用于命令和文本编辑, 而 emacs 采用了组合键的方式, 即使用键盘上的 Esc, Meta, Alt, Ctrl, Shift (因此坊间也戏称 emacs 为这一组功能键的头字母简写) 等功能键与字母区的按键组合来触发特定功能.<br>使用 emacs 时, 我们经常会将几个按键同时按下, 术语称之为键和弦, 在文档中, 用连字符将按键名相连来表示一个键和弦, 例如 <code>C-?</code> 表示将 Ctrl 键与 ? 按键一同按下, <code>M-?</code> 表示将 Meta 键与 ? 按键一同按下(作为非常古老的软件, emacs 的许多术语沿袭自计算机的洪荒年代, 现代美式键盘上没有 Meta 键, 我们使用 Alt 键作为替代; 有些键盘上也没有 Alt 键, 这时可以先按下 Esc 键然后释放, 再按 ? 键, 这种组合操作与 <code>M-?</code> 等效). 有些命令还需要配合上档键 Shift完成, 例如, 回到当前打开文件的首部的指令是 <code>M-&lt;</code>, 实际输入时需要同时按住 Alt, Shift 和 , 键.<br>Emacs自带的教程就是非常好的入门资料, 自然地, 我也选择从它来起步. 一边阅读一边参照着教程的指导进行练习, 认真过上几遍基本的操作就没什么大的问题了.<br>开启 emacs 内置教程的组合键为 <code>C-h t</code>, 意为同时按下 Ctrl 和 h, 松开, 然后再按 t 键. 如果系统的语言设置为中文, 则会默认开启已翻译中文的教程. 教程的组织形式简单明了, 还可以随时进行练习. 非常贴心的一点是, 修改过的 emacs 默认绑定键位也会在教程相应位置出现提示. Emacs 内置的文档也是必不可少的学习资料. 如果不确定某个组合键的功能, 遗忘了 ‘C-f’ 的作用, 可以使用 <code>C-h k C-f</code> 来查看对应的文档. 命令中的 k 指代 keyboard, 与之对应还有一条查询函数功能的命令: ‘C-h f’, 其中 f 指代 function. 使用组合键触发的功能还可以通过函数调用的方式来激活. 即使用 <code>M-x 函数名</code>. 许多函数会绑定到一些特定的组合键上. 这些函数大多数用 elisp 写成, 少数出于性能考虑使用 C 语言编写. Emacs 实际上可以视为一个 elisp 的解释环境, 其大多数的功能都通过这些函数来实现, 也允许用户自定义自己的 elisp 函数.<br>elisp 即 emacs lisp, 是一种专门用于 emacs 的 lisp 方言. 网上入门教程很多, 这里推荐看: <a href="https://learnxinyminutes.com/docs/elisp/" target="_blank" rel="external">learn x iny minutes where x = elisp</a>, 你可以将 el 格式(即 elisp 语言文件格式)下载到本地用 emacs 打开, 在实践过程中学习. 之后 emacs 的配置也需要懂一点 elisp 知识.</p>
<p>Emacs 的一组需要了解的特有术语和概念:<br>buffer:<br>简单地理解, emacs 中正在处理的一切都可以视为一个 buffer, 例如一个正在编辑的文件.<br>frame:<br>类似 windows 系统中 window (窗口)的概念.<br>window:<br>中文翻译为窗格, emacs 允许将一个 frame 划分为多个 window, 在不同的 window 中加载不同的 buffer 进行编辑操作. 出于历史原因, frame 与 window 与现在通用的术语含义有所区别.<br>point:<br>当前 window 中光标所在的位置.<br>echo area 与 minibuffer:<br>Echo area 位于 emacs 的 frame 的最下方, 会回显命令效果. 也是显示组合键输入缓存的地方. 比如 当 point 位于某个 elisp 函数后, 可以用’C-x C-e’ 执行它, 并将结果显示在 echo area 区域.(如果使用 ‘C-j’ 来执行函数, 结果会显示在 buffer 中 point 所在的位置.) 有的命令需要交互式地输入信息, 此时 echo area 会载入一个 minibuffer 供你进行编辑.</p>
<p>结合自带教程和一些补充资料, 就能对基础的命令和操作有一个初步的了解, 下面是我的学习总结:</p>
<p>滚屏操作:<br><code>C-v</code> 向前移动一屏.<br><code>M-v</code> 向后移动一屏.<br><code>C-l</code> 将 point 所在行居中; 再次输入会将 point 所在行置于屏幕顶端; 再次输入则移至底端.</p>
<p>基本的光标操作:<br><code>C-p</code> point 移动到上一行, p 代表 previous.<br><code>C-n</code> point 移动到下一行, n 代表 next.<br><code>C-b</code> point 向左移动一个字符, b 代表 backward.<br><code>C-f</code> point 向右移动一个字符, f 代表 forward.<br><code>M-b</code> point 移动到前一个”词首部”, emacs 是用空格区分词的, 因此在中文中, 效果是移动到上一句话的首部. 如果 point 位于词的中间, 则移动到当前词的首部.<br><code>M-f</code> point 移动到下一个”词尾部”.</p>
<p><code>C-a</code> point 移动到行首. a 代表 ahead.<br><code>C-e</code> point 移动到行尾, e 代表 end.<br><code>M-a</code> point 移动到段首.<br><code>M-e</code> point 移动到段尾.</p>
<p><code>M-&lt;</code> point 移动到 buffer 首部.<br><code>M-&gt;</code> point 移动到 buffer 尾部.</p>
<p>容易发现, Meta 主要用来操作由语言定义的单位(词,句,段), 而 Ctrl 常用来操作与编辑相关的单位(字符,行).</p>
<p>例如, Meta 组合键可以用来控制文本的大小写:<br><code>M-u</code> 当前词全部大写.<br><code>M-l</code> 当前词全部小写.<br><code>M-c</code> 当前词首字母大写, 其余小写.</p>
<p>常用的编辑操作:<br>普通的输入是所见即所得的, 不需要像 vim 那样切换到插入模式.</p>
<p><code>&lt;RET&gt;</code> 回车键可以换行. 实际上默认的回车绑定了 elisp 函数 newline.</p>
<p>删除/剪切操作如下:<br><code>&lt;del&gt;</code> 删去 point 所在位置的前一个字符.<br><code>C-d</code> 删去 point 所在位置的字符, d 代表 delete.<br><code>M-&lt;DEL&gt;</code> 剪切 point 所在位置的前一个词.<br><code>M-d</code> 剪切 point 所在位置的后一个词.<br><code>C-k</code> 剪切 point 所在位置到行尾的字符, 如果为空行则剪切行, k 代表 kill.<br><code>M-k</code> 剪切 point 所在位置到行首的字符.<br><code>C-w</code> 剪切当前选中的区域, 如没有选中区域, 剪切当前行.<br><code>C-&lt;SPC&gt;</code> 配合光标移动操作来选中一段文本. 在中文环境下会与输入法的热键冲突.<br><code>C-@</code> 效果等同 <code>C-&lt;SPC&gt;</code>.</p>
<p>实际运用时需要灵活使用多对组合键完成功能: 例如, 剪切一行的操作也可以用 <code>C-a C-k C-k</code>.</p>
<p>删除与剪切操作略有区别. 删除的字符不会保存, 而剪切的文本会保存在剪贴板中, 可以使用 <code>C-y</code> 将剪贴板的内容插入到 buffer 中 point 所在位置, 这里 y 代表 yank, 中文教程中翻译为召回.<br>连续使用的剪切操作会将内容保存在同一个剪贴板中, 使用 <code>C-y</code> 便能一次性将其召回.<br>如果要插入更老的剪切内容, 可以使用 <code>M-y</code>. 多次使用 <code>M-y</code> 能够轮询所有可用的剪贴板.</p>
<p>撤销操作:<br><code>C-/</code> 撤销上一个命令带来的所有改变.<br>与之等效的还有 <code>C-_</code>, ‘C-x u’.</p>
<p>为操作调用的函数附加参数:<br><code>C-u</code> 有些函数接受额外的参数. 使用键和弦 <code>C-u</code> 后可以输入一个数, 作为下一个命令调用的函数的参数传入. 数字参数的效果通常是重复执行函数的次数, 例如, <code>C-u 20 C-f</code> 的效果是 point 向前移动 20 个字符. 也有例外, 比如 <code>C-v</code> 和 <code>M-v</code> 在接受数字参数后, 参数将指定滚屏的行数而非屏数.<br><code>C-[NUM]</code> [NUM] 限制为 0~9 的数字. 效果类似 <code>C-u</code>.<br><code>M-[NUM]</code> 与 <code>C-[NUM]</code> 等效.<br>用以上命令便可以重复执行多次同一个函数了.</p>
<p>中止操作:<br><code>C-g</code> 中止失去响应或者执行过久的命令. 也可以用于取消数字参数和输入了一半的命令.</p>
<p>与 frame, window, buffer 相关的命令:<br>这种命令多以键和弦 <code>C-x</code> 开头.<br>例如回到 buffer 首部除了 <code>M-&lt;</code> 外也可以用 <code>C-x [</code>; 跳往 buffer 尾部除了 <code>M-&gt;</code> 还可以用 <code>C-x ]</code>.</p>
<p>可以在一个 frame 中打开多个 window.<br><code>C-x 2</code> 将当前的 window 水平划分为 2 个 windows.<br><code>C-x 3</code> 将当前的 window 竖直划分为 2 个 windows.<br>注意由于 window 的划分方式总是由一个 window 二分形成, 因此 所有的 windows 形成了一个二叉树形状的拓扑结构.<br><code>C-x 1</code> 关闭其他 window (注意不等同于关闭其他 window 显示的 buffer), 让当前 window 占据整个 frame.<br><code>C-x 0</code> 关闭当前window. 注意为数字 0 而不是字母 o.<br><code>C-x o</code> 跳转 window 操作. 将 point 跳转到下一个 window 的光标所在位置. 注意是字母 o 不是数字 0.<br><code>C-M-v</code> 滚动 windows 二叉树中的兄弟 window 的屏幕. 同时打开两个屏幕时这条命令非常实用. 能够在不切换窗格的情况下翻动另外一个窗格的内容.</p>
<p>打开文件的操作为:<br><code>C-x C-f</code> 打开文件. 打开一个文件并将其载入为一个 buffer, 如果没有则先创建一个新的 buffer. 载入后的 buffer 会占据当前的 window.<br><code>C-x C-v</code> 打开另一个文件. 关闭当前的 buffer, 并打开另一个文件将其载入为 buffer. 注意, 如果由多个 window 同时显示这个 buffer, 那么它们会一起被关闭并都载入新的 buffer.</p>
<p>保存文件的操作为:<br><code>C-x C-s</code> 将当前 window 的 buffer 保存到文件中. 如果对使用 <code>C-x C-f</code> 新建的 <code>buffer</code> 使用, 则此时将创建一个新文件.<br><code>C-x C-w</code> 相当于另存为.</p>
<p>切换当前 window 中载入的 buffer:<br><code>C-x C-b</code> 显示当前的 buffers 列表.<br><code>C-x b [BUFFER]</code> 在当前的 window 打开某个 buffer.<br><code>C-x s</code> 保存多个 buffers.<br>如果在有方向键的键盘上, <code>C-x</code> 加方向键可以在当前 window 中轮询切换所有打开的 buffers.</p>
<p>新建 frame:<br><code>M-x make-frame</code> 新建一个 frame, 在图形界面下可以同时显示多个 frame, 在命令行界面下只能显示一个 frame.<br><code>M-x delete-frame</code> 关闭当前所在的 frame.</p>
<p>撤销递归编辑:<br>当一次操作没有完成又进行了另外一次操作时, 将进入递归编辑状态(RECURSIVE EDITING LEVELS). 使用 <code>ESC ESC ESC</code> 可以退出递归编辑状态, 这条命令也可以用来关掉多余的 window 或者离开 minibuffer 区域.</p>
<p>其他命令:<br>emacs 提供的函数数量非常庞大, 而组合键的数量十分有限, 因此更多的函数调用通过<br><code>M-x 函数名</code>的方式来实现.</p>
<p>文本模式:<br>为了针对不同类型的文件和编辑操作使用不同的配置, Emacs 可以设置为不同的文本模式. 不同的文本模式下, emacs 处理文本的方式会有所区别.<br>文本模式会显示在 echo area 上方的状态栏 mode line 中. 状态栏显示的信息可以通过配置进行修改, 一般在光标位置信息右侧显示的就是文本模式信息.<br>文本模式分两类: 主模式 (major mode) 和辅模式 (minor mode). 主模式提供基本的配置, 辅模式可以提供额外的一些小功能. Emacs 同时有且只能设置为一种主模式, 但是可以设置多个辅模式.<br>缺省模式称为 Funamental, 它是一种主模式.<br>处理自然语言(如写日记)可以切换到 text-mode 下: 使用命令 <code>M-x text-mode</code> 即可. 咋看之下与缺省模式毫无区别, 但细心一些会发现 M-f 和 M-b 等处理单位为词的命令将单引号(‘)视为词的一部分了.<br>使用命令 <code>M-x auto-fill-mode</code> 可以打开一个具有自动换行功能的辅模式, 自动换行的行宽通过 <code>C-u</code> 向 <code>C-x f</code> 传入一个数字参数来设置, 默认设置一般为 70.<br>再次输入开启文本的模式命令能够关闭该模式.</p>
<p>搜索:<br><code>C-s</code> 从 point 位置向下文搜索.<br>这种搜索会从起点开始搜寻目标, 并将 point 移动到目标位置. 搜索并不是在命令完成后开始的, 一旦开始输入目标字符串, emacs 就会开始试图查找目标, 并将光标移动到符合结果的位置去, 如果使用 <code>&lt;DEL&gt;</code> 删除了目标字符串的一个字符, 光标会跳回上一个符合结果的目标处. 输入完成后, 再次按下 <code>C-s</code> 可以查找下一个符合的结果. 这种搜索方式称为增量搜索.<br>对应的命令还有:<br><code>C-r</code> 从 point 位置向上文搜索.<br>默认的这两条指令不是基于正则表达式的, 在我目前的配置中, 它们被替换为了基于正则表达式搜索的版本.</p>
<p>文档与帮助:<br>这类命令多以 <code>C-h</code> 打头.<br><code>C-h m</code> 查看当前文本模式的文档.<br><code>C-h k</code> 查看组合键文档.<br><code>C-h f</code> 查看函数文档.<br><code>C-h v</code> 查看当前环境中某个变量绑定的值.<br><code>C-h t</code> 自带教程.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>春节前开始正式地系统学习 emacs, 目前已经基本上能够做到正常使用了.<br>这篇文章并不是一篇有效的 emacs 教程, 主要用来记录学习过程中的一些心得.</p>
<p>接触 Emacs 之前以使用 vim/sublime 为主. 在这次学习之前, 对Emacs所知]]>
    </summary>
    
      <category term="Emacs" scheme="http://yoursite.com/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有关C语言的闲聊]]></title>
    <link href="http://yoursite.com/2016/02/08/%E6%9C%89%E5%85%B3C%E8%AF%AD%E8%A8%80%E7%9A%84%E9%97%B2%E8%81%8A/"/>
    <id>http://yoursite.com/2016/02/08/有关C语言的闲聊/</id>
    <published>2016-02-07T16:39:52.910Z</published>
    <updated>2016-02-07T16:39:52.882Z</updated>
    <content type="html"><![CDATA[<p>最近读k&amp;r c和其他C语言书籍的一些感想：</p>
<p>C是工程师在开发现场基于具体的开发目标而发明的语言。<br>它强大有力，赋予程序员非常大的权力和自由，但并不强调优美，统一，安全，健壮等在年轻的后进语言宣传语中经常听到的概念。</p>
<p>C的指针基本沿袭自B。在B语言中，指针和普通的整型没有本质区别，因而指针和整型的加减运算十分自然合理；然而在C语言中，引入了很多数据类型，情况变得复杂得多，指针的运算显得复杂晦涩，给初学者造成了许多障碍。<br>将C的指针简单地理解成内存地址并不十分合适，更恰当的理解应该是：指针的值为一个内存地址，而指针类型则可以表明指针所指向的内存块的大小，对指针+1操作，地址的增量并非1而取决于指针指向的引用类型的大小。</p>
<p>C语言的语法非常不统一。以声明语法为例，初学者往往会误以为其遵循<code>变量类型 变量名;</code>这样的形式，如<code>int a_num;</code>。<br>但对指针类型的声明(形如<code>int *p;</code>)并未遵从此形式：<code>int*</code>不是变量类型，倘若它是，那么<code>int* p1, p2;</code>就不至于导致歧义。<br>对此我的理解是，声明中出现的操作符并不具有与表达式中等同的语义，仅仅用来构成一定形式以表示某种数据类型。<br>例如<code>int arr[5];</code>声明了一个包含5个元素的整型数组，而在表达式中<code>arr[5]</code>意为<code>*(arr+5)</code>（或者也可以表示为<code>*(&amp;arr[0]+5)</code>）,两者语义相差甚远。</p>
<p>滥用C语言提供了一些语言特性很可能降低程序的可读性，甚至引入一些难以调试的隐性 bug。<br>例如老生常谈的自增自减运算符问题:<br>对变量增1减1确实是个使用场合非常多的操作，但<code>++</code>和<code>--</code>操作隐藏了赋值操作的副作用，如果表达式和语句中涉及对此变量的多处引用，则不适宜使用此类操作符。<br>为了追求短小紧凑，C程序经常试图将多个表达式/语句表示的语义压缩到一个表达式中，但C标准并没有严格定义表达式的求值顺序（只规定了操作符的求值顺序，以及副作用必须在某些语义结束点前发生，但语义结束点前副作用的顺序没有严格定义，这样编译器能获得更大的自由，从而在理论上可能进行更好的性能优化），因此<code>i+++i++</code>这类表达式的值属于未定义值，具体是多少有赖于编译器的实现。<br>k&amp;r c中专门强调了这个问题：</p>
<blockquote>
<p>The moral is that writing code that depends on order of evaluation is a bad programming practice in any language.</p>
</blockquote>
<p>即使程序的语义不依赖某个未定义数值，依然不推荐这样的写法，因为会大大增加维护的困难。</p>
<p>C程序有时会鼓励一些略显hack的写法。<br>例如k&amp;r c的例程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">This loop prints n elements of an array, 10 per line,</span><br><span class="line">with each column separated by one blank,</span><br><span class="line">and with each line (including the last) terminated by a newline.</span><br><span class="line">*/</span><br><span class="line">for (i = 0; i &lt; n; i++)</span><br><span class="line">    printf("%6d%c", a[i], (i%10==9 || i==n-1) ? '\n' : '');</span><br></pre></td></tr></table></figure></p>
<p>如果不借助注释很难一眼看懂代码(可能是我太弱:))。<br>考虑到C语言诞生的年代：电脑性能还十分低下，内存尚且非常昂贵，这种做法并不足以为奇。在单行代码中使用不是那么一目了然的紧凑写法其实并不会导致额外的维护工作，但却需要程序员之间建立一些不言而喻的约定俗成。<br>这种哲学如果推及其他语言并不一定合乎时宜，但以性能和紧凑为追求的C语言有充分的理由坚持。</p>
<p>总的来说，由于历史原因，C语言是一门不怎么严格的语言，对程序员提出了比较高的要求。C语言许多能算得上问题的问题，经常是解决具体问题时选择的折中和权衡。诚然，你需要克服许多看起来不是很必要的困难，但你因此变得更强大:)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近读k&amp;r c和其他C语言书籍的一些感想：</p>
<p>C是工程师在开发现场基于具体的开发目标而发明的语言。<br>它强大有力，赋予程序员非常大的权力和自由，但并不强调优美，统一，安全，健壮等在年轻的后进语言宣传语中经常听到的概念。</p>
<p>C的指针基本沿]]>
    </summary>
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[igcc:c/c++解释器]]></title>
    <link href="http://yoursite.com/2016/01/21/igcc-REPL-for-c-c/"/>
    <id>http://yoursite.com/2016/01/21/igcc-REPL-for-c-c/</id>
    <published>2016-01-21T11:55:29.019Z</published>
    <updated>2016-01-21T11:55:28.991Z</updated>
    <content type="html"><![CDATA[<p>最近在复习c/c++，苦于没有类似一些动态语言所提供的repl环境，难以方便地测试语法特性或实践短小简单的代码。</p>
<p>在网上搜罗了一圈，发现果然有已经解决了类似需求的轮子。<br>对比下来，igcc（交互式gcc编译器）是其中比较好用的一个。</p>
<p>项目主页见这里：<a href="http://www.artificialworlds.net/wiki/IGCC/IGCC" target="_blank" rel="external">http://www.artificialworlds.net/wiki/IGCC/IGCC</a></p>
<p>作者提供了比较清晰明了的安装以及使用指南。<br>目前最新版本是0.2, 上次更新是12年，看起来不太可能有后续更新了。<br>实际上sourceforge上的下载数目前都还是个位数，并没有多少人使用过，看来这个需求可能真的过于小众。</p>
<p>严格讲，igcc并非真正意义上的c/c++解释器，它利用python搭建了一个交互环境，封装了一些gcc的功能，其实际所执行的工作只是在录入每一行代码后编译并执行当前程序。<br>因此，它并不具有很多解释器提供的开箱计算器功能，只能执行完整且正确的c/c++代码。<br>当录入包含语法错误的代码时，它确实会像其他repl立即报错，但却依然会将错误代码保存到当前程序中，你需要通过预设的命令手动撤回所输入的命令。<br>输入<code>.h</code>你可以查看所有的预设命令。</p>
<p>尽管功能有限，但对学习者来说它已经足够方便。希望有类似（奇怪）需求的同学可以试用一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在复习c/c++，苦于没有类似一些动态语言所提供的repl环境，难以方便地测试语法特性或实践短小简单的代码。</p>
<p>在网上搜罗了一圈，发现果然有已经解决了类似需求的轮子。<br>对比下来，igcc（交互式gcc编译器）是其中比较好用的一个。</p>
<p>项目主]]>
    </summary>
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 nginx 和 nginx-rtmp 搭建流媒体服务器]]></title>
    <link href="http://yoursite.com/2015/12/29/%E4%BD%BF%E7%94%A8nginx%E5%92%8Cnginx-rtmp%E6%90%AD%E5%BB%BA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2015/12/29/使用nginx和nginx-rtmp搭建流媒体服务器/</id>
    <published>2015-12-28T18:38:00.846Z</published>
    <updated>2015-12-28T18:38:00.846Z</updated>
    <content type="html"><![CDATA[<p>我们在阿里云上搭建流媒体服务器, 服务端环境为 ubuntu14.04.</p>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>首先下载依赖:</p>
<ul>
<li>pcre 库（perl兼容正则表达式库）</li>
</ul>
<p>官网: www.pcre.org<br>下载地址: ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/<br><br><br>下载并解压到根目录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-<span class="number">8.37</span>.tar.gz</span><br><span class="line">tar zxvf pcre-<span class="number">8.37</span>.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>zlib 库</li>
</ul>
<p>官网: www.zlib.net</p>
<p>下载当前最新版本并解压到根目录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://sourceforge.net/projects/libpng/files/zlib/<span class="number">1.2</span>.<span class="number">8</span>/zlib-<span class="number">1.2</span>.<span class="number">8</span>.tar.gz</span><br><span class="line">tar zxvf zlib-<span class="number">1.2</span>.<span class="number">8</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>下载 nginx 最新版本并解压到根目录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-<span class="number">1.9</span>.<span class="number">9</span>.tar.gz</span><br><span class="line">tar zxvf nginx-<span class="number">1.9</span>.<span class="number">9</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>下载 nginx-rtmp 模块:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/arut/nginx-rtmp-module/archive/master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure>
<p>编译并安装:</p>
<p>切入 Nginx 的目录运行配置命令并编译安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx --pid-path=/var/run/nginx.pid --lock-path=/var/lock/nginx.lock --with-http_ssl_module --with-http_dav_module --with-http_flv_module --with-http_realip_module --with-http_gzip_static_module --with-http_stub_status_module --with-mail --with-mail_ssl_module --with-pcre=../pcre-<span class="number">8.37</span> --with-zlib=../zlib-<span class="number">1.2</span>.<span class="number">8</span> --with-debug --http-client-body-temp-path=/var/tmp/nginx/client --http-proxy-temp-path=/var/tmp/nginx/proxy --http-fastcgi-temp-path=/var/tmp/nginx/fastcgi --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi --http-scgi-temp-path=/var/tmp/nginx/scgi --add-module=../nginx-rtmp-module-master</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>关于各个配置参数的备注说明:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--prefix=/usr/<span class="built_in">local</span>/nginx <span class="comment"># 配置 nginx 安装目录, 默认位置在 /usr/local/nginx</span></span><br><span class="line">--pid-path=/var/run/nginx.pid <span class="comment"># 配置 pid 文件位置, 默认在 logs 目录</span></span><br><span class="line">--lock-path=/var/lock/nginx.lock <span class="comment"># 配置 lock 文件位置, 没人在 logs 目录</span></span><br><span class="line">--with-http_ssl_module <span class="comment"># 开启 http ssl 模块, 以支持 https 请求</span></span><br><span class="line">--with-http_dav_module <span class="comment"># 开启 WebDAV 扩展动作模块, 可以为文件和目录指定权限</span></span><br><span class="line">--with-http_flv_module <span class="comment"># 支持对 flv 文件的拖动播放</span></span><br><span class="line">--with-http_realip_module <span class="comment"># 支持显示真实来源的 ip 地址</span></span><br><span class="line">--with-http_gzip_static_module <span class="comment"># 在预压缩文件前做检查, 以免重复压缩</span></span><br><span class="line">--with-http_stub_status_module <span class="comment"># 取得 nginx 运行状态</span></span><br><span class="line">--with-mail <span class="comment"># 允许 pop3/imap4/smtp 代理模块</span></span><br><span class="line">--with-mail_ssl_module <span class="comment"># 允许 pop3/imap4/smtp 使用 ssl/tls</span></span><br><span class="line">--with-pcre=../pcre-<span class="number">8.37</span> <span class="comment"># 这里是未安装的 pcre 库路径, 即刚才解压的路径</span></span><br><span class="line">--with-zlib=../zlib-<span class="number">1.2</span>.<span class="number">8</span> <span class="comment"># 这里是未安装的 zlib 库路径, 即刚才解压的路径 </span></span><br><span class="line">--with-debug <span class="comment"># 开启调试日志</span></span><br><span class="line">--http-client-body-temp-path=/var/tmp/nginx/client <span class="comment"># 客户端请求临时位置</span></span><br><span class="line">--http-proxy-temp-path=/var/tmp/nginx/proxy <span class="comment"># 设置 http proxy 临时文件路径</span></span><br><span class="line">--http-fastcgi-temp-path=/var/tmp/nginx/fastcgi <span class="comment"># 设置 http fastcgi 临时文件路径</span></span><br><span class="line">--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi <span class="comment"># 设置 uwsgi 临时文件路径</span></span><br><span class="line">--http-scgi-temp-path=/var/tmp/nginx/scgi <span class="comment"># 设置 scgi 临时文件路径 </span></span><br><span class="line">--add-module=../nginx-rtmp-module-master <span class="comment"># 安装 nginx-rtmp 模块, 路径为刚才解压的位置</span></span><br></pre></td></tr></table></figure>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>在文件末尾添加对 rtmp 协议的配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rtmp</span> &#123;</span><br><span class="line">    <span class="title">listen</span> <span class="number">1935</span>;</span><br><span class="line">    <span class="title">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title">application</span> live &#123;</span><br><span class="line">        <span class="title">live</span> <span class="built_in">on</span>;</span><br><span class="line">        <span class="title">record</span> <span class="built_in">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意要放在文件的根位置, 不要写在 <code>http</code> 的花括号中.</p>
<p>以上配置仅供测试, 详细配置需要参考 <code>nginx-rtmp</code> 的 <a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives" target="_blank" rel="external">wiki</a>.</p>
<h2 id="u8FD0_u884C"><a href="#u8FD0_u884C" class="headerlink" title="运行"></a>运行</h2><p>运行服务器:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
<p>运行时会占用 <code>80</code> 端口和 <code>1935</code> 端口.</p>
<p>退出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/nginx/sbin/nginx <span class="operator">-s</span> quit</span><br></pre></td></tr></table></figure>
<h2 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h2><p>我们使用 obs 录屏通过流媒体服务器转发 b 站来测试.</p>
<p>需要额外准备两个条件:</p>
<ol>
<li>obs 客户端;</li>
<li>b站直播间.</li>
</ol>
<p>我们先下载安装配置 obs 客户端:<br>obs 的官网地址: <a href="https://obsproject.com/" target="_blank" rel="external">https://obsproject.com/</a>. </p>
<p>obs 是一个用于直播录制的跨平台自由软件, 有针对 window， mac 和 linux 平台的发行版本. 对 linux 平台, ubuntu 上有官方构建版本, Arch Linux, OpenSUSE, Gentoo 有第三方构建版本, 其余发行版需要自己编译.</p>
<p>我们使用的客户端环境是 <code>ubuntu 15.04</code>， 参见 obs 官方说明安装 obs 客户端:</p>
<p>obs 依赖 FFmpeg, 如果尚未安装需要先安装 FFmpeg:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure>
<p>添加 obs 的源然后安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:obsproject/obs-studio</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install obs-studio</span><br></pre></td></tr></table></figure>
<p>运行 obs, 在设置-串流中设置串流类型为自定义, 在 URL 一栏填写阿里云服务器 ip, 流密钥一栏填入 <code>test</code>(使用前文默认配置时).</p>
<p>打开 <code>http://live.bilibili.com/</code> , 进入自己的直播间(如果没有权限需要事先申请, b 站直播申请需要实名认证), 开始直播后 会弹出包含直播码的对话框.</p>
<p>修改 nginx 的配置文件(<code>/usr/local/nginx/conf/nginx.conf</code>):</p>
<p>在 <code>record off</code> 后添加一行:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> rtmp:<span class="comment">//live-send.acg.tv/live/&lt;你的直播码&gt;;</span></span><br></pre></td></tr></table></figure>
<p>重启 nginx 服务器.</p>
<p>回到 obs 界面, 点击开始录制和开始串流按钮, 如果一切正常, 你的屏幕画面应该会出现在直播间的屏幕上.</p>
<p>在上述配置文件中还可以添加多个 <code>pushes</code>, 从而实现向多个直播平台推流.</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://obsproject.com/forum/resources/how-to-set-up-your-own-private-rtmp-server-using-nginx.50/" target="_blank" rel="external">How to set up your own private rtmp server using nginx</a></p>
</li>
<li><p><a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives" target="_blank" rel="external">nginx-rtmp-module-wiki</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们在阿里云上搭建流媒体服务器, 服务端环境为 ubuntu14.04.</p>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>首先下载依赖:<]]>
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google JS 代码风格指南（5）]]></title>
    <link href="http://yoursite.com/2015/12/27/Google-JS-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%885%EF%BC%89/"/>
    <id>http://yoursite.com/2015/12/27/Google-JS-代码风格指南（5）/</id>
    <published>2015-12-27T06:32:29.463Z</published>
    <updated>2015-12-27T06:32:29.463Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title="JavaScript 代码风格指南"></a>JavaScript 代码风格指南</h2><p>这份指南列出了编写 JavaScript 时需要遵守的规范, 指明哪些应该<strong>提倡</strong>, 哪些应该<del>避免</del>.<br>本文基于 google 的规范翻译整理(JavaScript 是许多 Google 开源项目使用的主要客户端脚本语言).</p>
<h3 id="285_29"><a href="#285_29" class="headerlink" title="(5)"></a>(5)</h3><h3 id="JavaScript__u4EE3_u7801_u98CE_u683C_u89C4_u8303_284_29"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u89C4_u8303_284_29" class="headerlink" title="JavaScript 代码风格规范(4)"></a>JavaScript 代码风格规范(4)</h3><p><strong> 编译 </strong></p>
<blockquote>
<p>应该如此.</p>
</blockquote>
<p>所有面向消费者的代码项目都应该使用像 the Closure Compiler 这样的 JS 编译器.</p>
<p><strong> 提示与技巧 </strong></p>
<blockquote>
<p>JavaScript 小花絮</p>
</blockquote>
<h6 id="u771F_u6216_u5047__u5E03_u5C14_u8868_u8FBE_u5F0F"><a href="#u771F_u6216_u5047__u5E03_u5C14_u8868_u8FBE_u5F0F" class="headerlink" title="真或假 布尔表达式"></a>真或假 布尔表达式</h6><p>下列表达式皆为假:</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>‘’ 空字符串</li>
<li>0 数字0</li>
</ul>
<p>但切记小心, 因为下面这些都为’真’:</p>
<ul>
<li>‘0’ ‘0’的字符串</li>
<li>[] 空数组</li>
<li>{} 空对象</li>
</ul>
<p>这意味着与其这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x != <span class="literal">null</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>不如写得更短一些 (只要你能确定 x 不会是 0, 空串或者其他假值就行):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x) &#123;</span><br></pre></td></tr></table></figure>
<p>如果想要判断字符串是否为空串或者为 null 类型, 你可以这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (y != <span class="literal">null</span> &amp;&amp; y != <span class="string">''</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>但直接写成这样其实更短更好:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (y) &#123;</span><br></pre></td></tr></table></figure>
<p>警告: 还有很多不那么直观的布尔表达式, 比如下面这些:</p>
<ul>
<li><code>Boolean(&#39;0&#39;) == true</code><br><code>&#39;0&#39; != true</code></li>
<li><code>0 != null</code><br><code>0 == []</code><br><code>0 == false</code></li>
<li><code>Boolean(null) == false</code><br><code>null != true</code><br><code>null != false</code></li>
<li><code>Boolean(undefined) == false</code><br><code>undefined != true</code><br><code>undefined != false</code></li>
<li><p><code>Boolean([]) == true</code><br><code>[] != true</code><br><code>[] == false</code></p>
</li>
<li><p><code>Boolean({}) == true</code><br><code>{} != true</code><br><code>{} != false</code></p>
</li>
</ul>
<h6 id="u6761_u4EF6_u64CD_u4F5C_u7B26/_u4E09_u5143_u64CD_u4F5C_u7B26__28_3F_3A_29"><a href="#u6761_u4EF6_u64CD_u4F5C_u7B26/_u4E09_u5143_u64CD_u4F5C_u7B26__28_3F_3A_29" class="headerlink" title="条件操作符/三元操作符 (?:)"></a>条件操作符/三元操作符 (?:)</h6><p>与其这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">  <span class="keyword">return</span> foo();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不如像这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> val ? foo() : bar();</span><br></pre></td></tr></table></figure>
<p>在生成 HTML 时三元操作符也非常有用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">'&lt;input type="checkbox"'</span> +</span><br><span class="line">    (isChecked ? <span class="string">' checked'</span> : <span class="string">''</span>) +</span><br><span class="line">    (isEnabled ? <span class="string">''</span> : <span class="string">' disabled'</span>) +</span><br><span class="line">    <span class="string">' name="foo"&gt;'</span>;</span><br></pre></td></tr></table></figure>
<p>#####　&amp;&amp; and ||</p>
<p>这些二元布尔操作符都可以进行短路求值，　以此来决定是否需要计算最后一项．</p>
<p><code>||</code> 有时也被认为默认操作符，　因为与其写成这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @param &#123;*=&#125; opt_win */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">opt_win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> win;</span><br><span class="line">  <span class="keyword">if</span> (opt_win) &#123;</span><br><span class="line">    win = opt_win;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    win = <span class="built_in">window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还可以写成这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @param &#123;*=&#125; opt_win */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">opt_win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> win = opt_win || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&amp;&amp;</code> 也能够用于缩短代码. 举例来说, 与其这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.kids) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.kids[index]) &#123;</span><br><span class="line">      foo(node.kids[index]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不如像这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) &#123;</span><br><span class="line">  foo(node.kids[index]);</span><br><span class="line">&#125;</span><br><span class="line">or <span class="keyword">this</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];</span><br><span class="line"><span class="keyword">if</span> (kid) &#123;</span><br><span class="line">  foo(kid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过如何像这样, 就有点玩过头了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node &amp;&amp; node.kids &amp;&amp; node.kids[index] &amp;&amp; foo(node.kids[index]);</span><br></pre></td></tr></table></figure>
<h6 id="u8FED_u4EE3_u8282_u70B9_u5217_u8868"><a href="#u8FED_u4EE3_u8282_u70B9_u5217_u8868" class="headerlink" title="迭代节点列表"></a>迭代节点列表</h6><p>通常我们使用过滤器将节点列表作为节点迭代器引入. 这意味着得到节点的属性所需的时间复杂度为 O(n), 而通过 <code>length</code> 遍历整个列表则需要 O(n^2).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraphs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">  doSomething(paragraphs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更好的写法是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraphs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, paragraph; paragraph = paragraphs[i]; i++) &#123;</span><br><span class="line">  doSomething(paragraph);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法适合于各种集合和数组, 只要数组元素中不包含为假值的布尔量.</p>
<p>你也可以使用 <code>firstChild</code> 和 <code>nextSibling</code> 来遍历子节点.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentNode = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> child = parentNode.firstChild; child; child = child.nextSibling) &#123;</span><br><span class="line">  doSomething(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h3><p>保持风格统一.</p>
<p>如果你正在编辑代码, 花几分钟检测下手头的代码来确定它属于何种风格. 如果他们都在运算符周围使用空格, 那你也应该照办. 如果他们的注释都放在用虚线围成的小盒子里, 那你的注释也同样应该用虚线小盒子围起来.</p>
<p>使用代码风格规范的重点在于, 建立一个共通的代码语汇, 这样人们就能将重点更多放在你要表述的内容而非你怎样去表述内容. 我们提出一份基本的规范让人们了解这些语汇, 但具体项目中使用的局部规范也很重要. 如果你编写的代码看上去与项目中已经存在的其他代码大相径庭, 那么就会扰乱阅读者的节奏. 理应避免这样.</p>
<ul>
<li>修订版本 2.93</li>
</ul>
<p>作者列表:</p>
<ul>
<li>Aaron Whyte</li>
<li>Bob Jervis</li>
<li>Dan Pupius</li>
<li>Erik Arvidsson</li>
<li>Fritz Schneider</li>
<li>Robby Walke</li>
</ul>
<p>汉化列表:</p>
<ul>
<li>crafteverywhere</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google JS 代码风格指南（4）]]></title>
    <link href="http://yoursite.com/2015/12/27/Google-JS-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%884%EF%BC%89/"/>
    <id>http://yoursite.com/2015/12/27/Google-JS-代码风格指南（4）/</id>
    <published>2015-12-27T06:31:32.423Z</published>
    <updated>2015-12-27T06:31:32.423Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title="JavaScript 代码风格指南"></a>JavaScript 代码风格指南</h2><p>这份指南列出了编写 JavaScript 时需要遵守的规范, 指明哪些应该<strong>提倡</strong>, 哪些应该<del>避免</del>.<br>本文基于 google 的规范翻译整理(JavaScript 是许多 Google 开源项目使用的主要客户端脚本语言).</p>
<h3 id="284_29"><a href="#284_29" class="headerlink" title="(4)"></a>(4)</h3><h3 id="JavaScript__u4EE3_u7801_u98CE_u683C_u89C4_u8303_283_29"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u89C4_u8303_283_29" class="headerlink" title="JavaScript 代码风格规范(3)"></a>JavaScript 代码风格规范(3)</h3><h4 id="u6CE8_u91CA"><a href="#u6CE8_u91CA" class="headerlink" title="注释"></a>注释</h4><p>使用 JSDoc.</p>
<blockquote>
<p>在精神上, 我们遵循<a href="http://google.github.io/styleguide/cppguide.xml#Comments" target="_blank" rel="external"> C++ 注释风格</a>的指导.</p>
</blockquote>
<p>所有文件, 类, 方法和属性都应该通过合适的<a href="http://google.github.io/styleguide/javascriptguide.xml#JSDoc_Tag_Reference" target="_blank" rel="external">标签</a>和<a href="http://google.github.io/styleguide/javascriptguide.xml#JsTypes" target="_blank" rel="external">类型说明</a>使用 <a href="http://code.google.com/p/jsdoc-toolkit/" target="_blank" rel="external">JSDoc</a> 进行注释. 除非从属性, 方法和参数的命名中可以清晰地判断其用途, 否则在注释中应当包含对属性, 方法, 方法参数和方法返回值的文字描述.</p>
<p>行内注释应当使用 <code>//</code>.</p>
<p>推荐在注释中使用完整的句子, 但不做严格要求. 完整句子应当正确使用大小写和标点符号.</p>
<p><strong> 注释语法 </strong></p>
<p>JSDoc 的语法基于 <a href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html" target="_blank" rel="external">JavaDoc</a>. 有许多工具可以从 JSDoc 注释中提取元数据来执行代码校验和优化. 这些注释必须遵循正确的格式.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * JSDoc 的注释应当以斜划线和两个星号打头.</span><br><span class="line"> * 行内标签应该放在闭合的花括号中, 就像这样: &#123;@code this&#125;.</span><br><span class="line"> * @desc 块级标签应当总是另起新行.</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p><strong> JSDoc 缩进 </strong></p>
<p>如果你需要对一个块级标签折行, 你应当就像视其为代码块那样缩进 4 格.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 长参数和返回值描述的折行处理示例.</span><br><span class="line"> * @param &#123;string&#125; foo 这是某个参数的描述, 由于太长太长太长太长太长太长太长以至于一行内</span><br><span class="line"> *     有点放不下.</span><br><span class="line"> * @return &#123;number&#125; 这是某个返回值的描述, 由于太长太长太长太长太长太长太长以至于一行内</span><br><span class="line"> *     有点放不下.</span><br><span class="line"> */</span></span><br><span class="line">project.MyClass.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你不应该缩进 <code>@fileoverview</code> 命令. 你不必缩进 <code>@desc</code> 命令.</p>
<p>即使并不推荐, 但对齐缩进的方式也可以接受.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 并不推荐的缩进方式..</span><br><span class="line"> * @param &#123;string&#125; foo 这是某个参数的描述, 由于太长太长太长太长太长太长太长以至于一行内</span><br><span class="line"> *                     有点放不下.</span><br><span class="line"> * @return &#123;number&#125; 这是某个返回值的描述, 由于太长太长太长太长太长太长太长以至于一行内</span><br><span class="line"> *                  有点放不下.</span><br><span class="line"> */</span></span><br><span class="line">project.MyClass.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong> JSDoc 中的 HTML </strong></p>
<p>类似 JavaDoc, JSDoc 也支持许多 HTML 标签, 诸如 <code>&lt;code&gt;</code>, <code>&lt;pre&gt;</code>, <code>&lt;tt&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code>, <code>&lt;a&gt;</code> 等等.</p>
<p>这意味着最好不要对纯文本格式化, 不要依赖用空格来格式化 JSDoc:</p>
<p>不要像这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Computes weight based on three factors:</span><br><span class="line"> *   items sent</span><br><span class="line"> *   items received</span><br><span class="line"> *   last timestamp</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>输出后它会这样显示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computes weight based on three factors: items sent items received last timestamp</span><br></pre></td></tr></table></figure>
<p>应该这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Computes weight based on three factors:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;items sent</span><br><span class="line"> * &lt;li&gt;items received</span><br><span class="line"> * &lt;li&gt;last timestamp</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>如何书写排版优美的文档注释可以参看这篇文章: <a href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html" target="_blank" rel="external">JSDoc 风格指南</a>.</p>
<p><strong> 顶级/文件级注释 </strong></p>
<p>版权提示和作者信息是可选的.<br>无论文件是否包含超过一个类的定义, 一般都推荐加上文件概述.<br>顶级注释主要面向不熟悉代码的读者, 让他们大致了解文件内代码的用途.<br>因此注释中应当提供文件内容的描述, 依赖关系或者兼容信息.<br>下面是一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @fileoverview Description of file, its uses and information</span><br><span class="line"> * about its dependencies.</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p><strong> 类注释 </strong></p>
<p>类的文档注释应当包含一份描述信息和<a href="http://google.github.io/styleguide/javascriptguide.xml#constructor-tag" target="_blank" rel="external">定义构造函数的类型标签</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 类让事情变得简单又有趣.</span><br><span class="line"> * @param &#123;string&#125; arg1 让它变得更有趣的参数.</span><br><span class="line"> * @param &#123;Array.&lt;number&gt;&#125; arg2 待处理的数字列表.</span><br><span class="line"> * @constructor</span><br><span class="line"> * @extends &#123;goog.Disposable&#125;</span><br><span class="line"> */</span></span><br><span class="line">project.MyClass = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">goog.inherits(project.MyClass, goog.Disposable);</span><br></pre></td></tr></table></figure>
<p><strong> 方法和函数注释 </strong></p>
<p>应当包含参数和返回值类型的文档注释. 如果从参数或者返回值类型描述中明显能看出方法的作用, 那么可以省略对方法的描述. 方法描述应该使用第三人称的陈述句来开头.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 对 MyClass 的一个实例进行操作并返回了一些东西.</span><br><span class="line"> * @param &#123;project.MyClass&#125; obj MyClass 的实例, 有个老长老长老长的注释, 长到需要</span><br><span class="line"> *     放到拆成两行来显示.</span><br><span class="line"> * @return &#123;boolean&#125; 判断某些事情是否发生.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PR_someMethod</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 属性注释 </strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @constructor */</span></span><br><span class="line">project.MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Maximum number of things per pane.</span><br><span class="line">   * @type &#123;number&#125;</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">this</span>.someProperty = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> JSDoc 标签参考 </strong></p>
<p>参见下表：</p>
<p><a href="/static/JSDoc.html">JSDoc 标签</a></p>
<p>你还可以在第三方代码中看到许多其他类型的 JSDoc 注解. 整个注解可以在 JSDoc 工具箱标签索引中查询到, 但并不鼓励用于 Google 项目中. 你可以视这些注解为保留名, 可能会在将来投入使用. 它们包括:</p>
<ul>
<li>@augments</li>
<li>@argument</li>
<li>@borrows</li>
<li>@class</li>
<li>@constant</li>
<li>@constructs</li>
<li>@default</li>
<li>@event</li>
<li>@example</li>
<li>@field</li>
<li>@function</li>
<li>@ignore</li>
<li>@inner</li>
<li>@link</li>
<li>@memberOf</li>
<li>@name</li>
<li>@namespace</li>
<li>@property</li>
<li>@public</li>
<li>@requires</li>
<li>@returns</li>
<li>@since</li>
<li>@static</li>
<li>@version</li>
</ul>
<p><strong> 使用 goog.provide 提供依赖项 </strong></p>
<blockquote>
<p>只引入最顶级的符号.</p>
</blockquote>
<p>一个类定义的所有成员都应处于同一文件中. 因此, 在包含多个定义在同一类中的复数成员的文件中, 只应该引入最顶级的符号(例如枚举类型和内部类等).</p>
<p>应该这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goog.provide(<span class="string">'namespace.MyClass'</span>);</span><br></pre></td></tr></table></figure>
<p>不要这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">goog.provide(<span class="string">'namespace.MyClass'</span>);</span><br><span class="line">goog.provide(<span class="string">'namespace.MyClass.Enum'</span>);</span><br><span class="line">goog.provide(<span class="string">'namespace.MyClass.InnerClass'</span>);</span><br><span class="line">goog.provide(<span class="string">'namespace.MyClass.TypeDef'</span>);</span><br><span class="line">goog.provide(<span class="string">'namespace.MyClass.CONSTANT'</span>);</span><br><span class="line">goog.provide(<span class="string">'namespace.MyClass.staticMethod'</span>);</span><br><span class="line">Members on namespaces may also be provided:</span><br><span class="line"></span><br><span class="line">goog.provide(<span class="string">'foo.bar'</span>);</span><br><span class="line">goog.provide(<span class="string">'foo.bar.method'</span>);</span><br><span class="line">goog.provide(<span class="string">'foo.bar.CONSTANT'</span>);</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google JS 代码风格指南（3）]]></title>
    <link href="http://yoursite.com/2015/12/27/Google-JS-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2015/12/27/Google-JS-代码风格指南（3）/</id>
    <published>2015-12-27T06:31:01.518Z</published>
    <updated>2015-12-27T06:31:01.518Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title="JavaScript 代码风格指南"></a>JavaScript 代码风格指南</h2><p>这份指南列出了编写 JavaScript 时需要遵守的规范, 指明哪些应该<strong>提倡</strong>, 哪些应该<del>避免</del>.<br>本文基于 google 的规范翻译整理(JavaScript 是许多 Google 开源项目使用的主要客户端脚本语言).</p>
<h3 id="283_29"><a href="#283_29" class="headerlink" title="(3)"></a>(3)</h3><h3 id="JavaScript__u4EE3_u7801_u98CE_u683C_u89C4_u8303_282_29"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u89C4_u8303_282_29" class="headerlink" title="JavaScript 代码风格规范(2)"></a>JavaScript 代码风格规范(2)</h3><h4 id="Javascript__u7C7B_u578B"><a href="#Javascript__u7C7B_u578B" class="headerlink" title="Javascript 类型"></a>Javascript 类型</h4><p>鼓励和强制使用编译器.</p>
<p>既然使用 JSDoc 来文档化, 那就尽可能规范和准确. 支持的类型基于 <a href="http://wiki.ecmascript.org/doku.php?id=spec:spec" target="_blank" rel="external">EcmaScript 4 spec</a>.</p>
<p><strong> JS 类型语言 </strong></p>
<p>ES4 建议中包含一种用于 JS 类型说明的语言. 我们在 JSDoc 中使用这种语言来说明函数的类型和返回值.</p>
<p>由于 ES4 建议还处于发展中, 因此这种说明语言已经有所变化. 编译器依然支持旧的类型语法, 单这些语法已经被废弃来.</p>
<p>参见下表:</p>
<p><a href="/static/js类型语言.html">JS 类型语言</a></p>
<p><strong> JS 中的类型 </strong></p>
<p>参见下表：</p>
<p><a href="/static/js中的类型.html">JS 中的类型</a></p>
<p><strong> 类型转换 </strong></p>
<p>在那些类型检查基于表达式推断不够准确的情况中, 可以使用类型注解来增加一些类型转换注释, 并且用圆括号括起表达式. 圆括号是必须的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @type &#123;number&#125; */</span> (x)</span><br></pre></td></tr></table></figure>
<p><strong> 可空类型 vs. 可缺省参数/属性 </strong></p>
<p>由于 JS 属于弱类型语言. 因此理解可缺省, 可空和未定义函数参数和类属性之间的微妙差异是非常重要的.</p>
<p>接口以及类的实例默认是可空类型. 例如下面的声明:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 一些类, 用一个值来初始化.</span><br><span class="line"> * @param &#123;Object&#125; value Some value.</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 一些值.</span><br><span class="line">   * @type &#123;Object&#125;</span><br><span class="line">   * @private</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">this</span>.myValue_ = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>告诉编译器 <code>myValue_</code> 属性既可能是对象也可能是 <code>null</code>. 如果不允许 <code>myValue_</code> 为 <code>null</code> 则应该像这样声明:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Some class, initialized with a non-null value.</span><br><span class="line"> * @param &#123;!Object&#125; value Some value.</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Some value.</span><br><span class="line">   * @type &#123;!Object&#125;</span><br><span class="line">   * @private</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">this</span>.myValue_ = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果采用这种方式, 当编译器检测到某段代码中 <code>MyClass</code> 使用 <code>null</code> 来初始化时, 就会报警告.</p>
<p>函数的可缺省参数在运行时可能是未定义的, 因此如果它们被赋给类的属性, 这些属性必须相应地声明:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 一些类, 包含可缺省参数被初始化.</span><br><span class="line"> * @param &#123;Object=&#125; opt_value Some value (optional).</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params">opt_value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 一些值.</span><br><span class="line">   * @type &#123;Object|undefined&#125;</span><br><span class="line">   * @private</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">this</span>.myValue_ = opt_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码告诉编译器 <code>myValue_</code> 可能包含一个对象, <code>null</code> 或未定义类型.</p>
<p>注意可缺省参数 <code>opt_value</code> 以类型 <code>{Object=}</code> 来声明, 而非 <code>{Object|undefined}</code>. 这是因为可缺省参数也有可能会是未定义类型. 虽然显式地说明可缺省变量可能是未定义类型并不会有什么害处, 但是这样既无必要也会降低代码的可读性.</p>
<p>最后, 注意可空类型和可缺省类型都是正交属性. </p>
<p>下面的四种声明都是不同的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 接受 4 格参数, 其中两个是可空类型, 两个是可缺省类型.</span><br><span class="line"> * @param &#123;!Object&#125; nonNull Mandatory (must not be undefined), must not be null.</span><br><span class="line"> * @param &#123;Object&#125; mayBeNull Mandatory (must not be undefined), may be null.</span><br><span class="line"> * @param &#123;!Object=&#125; opt_nonNull Optional (may be undefined), but if present,</span><br><span class="line"> *     must not be null!</span><br><span class="line"> * @param &#123;Object=&#125; opt_mayBeNull Optional (may be undefined), may be null.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strangeButTrue</span>(<span class="params">nonNull, mayBeNull, opt_nonNull, opt_mayBeNull</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong> 类型定义 </strong></p>
<p>有时类型可以变得非常复杂. 一个接受某个元素内容的函数可能看上去会是这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;string&#125; tagName</span><br><span class="line"> * @param &#123;(string|Element|Text|Array.&lt;Element&gt;|Array.&lt;Text&gt;)&#125; contents</span><br><span class="line"> * @return &#123;!Element&#125;</span><br><span class="line"> */</span></span><br><span class="line">goog.createElement = <span class="function"><span class="keyword">function</span>(<span class="params">tagName, contents</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>@typedef</code> 来标记常见的类型表达式, 比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @typedef &#123;(string|Element|Text|Array.&lt;Element&gt;|Array.&lt;Text&gt;)&#125; */</span></span><br><span class="line">goog.ElementContent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;string&#125; tagName</span><br><span class="line"> * @param &#123;goog.ElementContent&#125; contents</span><br><span class="line"> * @return &#123;!Element&#125;</span><br><span class="line"> */</span></span><br><span class="line">goog.createElement = <span class="function"><span class="keyword">function</span>(<span class="params">tagName, contents</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong> 模板类型 </strong></p>
<p>编译器已经对模板类提供了有限度的支持. 它只能通过 <code>this</code> 参数的类型和 <code>this</code> 参数是否遗失来判断匿名函数字面量中的 <code>this</code> 类型.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;function(this:T, ...)&#125; fn</span><br><span class="line"> * @param &#123;T&#125; thisObj</span><br><span class="line"> * @param &#123;...*&#125; var_args</span><br><span class="line"> * @template T</span><br><span class="line"> */</span></span><br><span class="line">goog.bind = <span class="function"><span class="keyword">function</span>(<span class="params">fn, thisObj, var_args</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可能会产生属性遗失的警告.</span></span><br><span class="line">goog.bind(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.someProperty; &#125;, <span class="keyword">new</span> SomeClass());</span><br><span class="line"><span class="comment">// 会产生未定义 this 的警告.</span></span><br><span class="line">goog.bind(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.someProperty; &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google JS 代码风格指南（2）]]></title>
    <link href="http://yoursite.com/2015/12/27/Google-JS-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2015/12/27/Google-JS-代码风格指南（2）/</id>
    <published>2015-12-27T06:29:46.422Z</published>
    <updated>2015-12-27T06:29:46.422Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title="JavaScript 代码风格指南"></a>JavaScript 代码风格指南</h2><p>这份指南列出了编写 JavaScript 时需要遵守的规范, 指明哪些应该<strong>提倡</strong>, 哪些应该<del>避免</del>.<br>本文基于 google 的规范翻译整理(JavaScript 是许多 Google 开源项目使用的主要客户端脚本语言).</p>
<h3 id="282_29"><a href="#282_29" class="headerlink" title="(2)"></a>(2)</h3><h3 id="JavaScript__u4EE3_u7801_u98CE_u683C_u89C4_u8303_281_29"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u89C4_u8303_281_29" class="headerlink" title="JavaScript 代码风格规范(1)"></a>JavaScript 代码风格规范(1)</h3><h4 id="u547D_u540D_u89C4_u8303"><a href="#u547D_u540D_u89C4_u8303" class="headerlink" title="命名规范"></a>命名规范</h4><ul>
<li>一般情况下,按下列命名规范即可:</li>
<li>函数命名: <code>functionNamesLikeThis</code> (首字母小写驼峰式)</li>
<li>变量命名: <code>variableNamesLikeThis</code> (首字母小写驼峰式)</li>
<li>类命名: <code>ClassNamesLikeThis</code> (首字母大写驼峰式)</li>
<li>枚举量命名: <code>EnumNamesLikeThis</code> (首字母大写驼峰式)</li>
<li>方法命名: <code>methodNamesLikeThis</code> (首字母小写驼峰式)</li>
<li>常量命名: <code>CONSTANT_VALUES_LIKE_THIS</code> (全字母大写下划线式)</li>
<li>命名空间命名: <code>foo.namespaceNamesLikeThis.bar</code> (首字母小写驼峰式)</li>
<li>文件命名: <code>filenameslikethis.js</code> (全小写)</li>
</ul>
<p>译者附注：<br>在 google 规范的基础上， 我们还可以作如下调整：<br>变量命名在局部作用域使用 <code>variable_names_like_this</code> 全小写下划线分隔<br>变量命名在模块作用域使用 <code>variableNamesLikeThis</code> 首字母小写驼峰式</p>
<p>变量命名的基本规范：</p>
<ul>
<li>变量名只使用 a~z, A~Z, 0~9, 下划线， 中划线和 $ 符号.</li>
<li>变量名不能数字开头.</li>
</ul>
<p>应该在布尔量前加上前缀来区别于普通变量</p>
<ul>
<li>通用 <code>bool_var</code> <code>boolVar</code></li>
<li>请求 <code>do_verb</code> <code>doVerb</code></li>
<li>包含 <code>has_var</code> <code>hasVar</code></li>
<li>状态 <code>is_var</code> <code>isVar</code></li>
<li>绑定事件 ‘on_var’ ‘onVar’</li>
</ul>
<p>对正则变量加上前缀 <code>regex</code>, 如 <code>regex_var</code> 和 <code>regexVar</code>.</p>
<p>变量后可以选择加后缀来标识其用途，如果处于合理的伪命名空间中，也可以不用:</p>
<ul>
<li>通用 <code>var_str</code> <code>varStr</code></li>
<li>标识 <code>var_id</code> <code>varId</code></li>
<li>HTML <code>var_html</code> <code>varHtml</code></li>
<li>消息 <code>var_msg</code> <code>varMsg</code></li>
<li>名字 <code>var_name</code> <code>varName</code></li>
<li>文本 <code>var_text</code> <code>varText</code></li>
<li>类型 <code>var_type</code> <code>var_Type</code></li>
<li>图片 <code>var_img</code> <code>varImg</code></li>
<li>声音 <code>var_snd</code> <code>varSnd</code></li>
<li>列表 <code>var_list</code> <code>varList</code></li>
<li>数据 <code>var_data</code> <code>varData</code></li>
<li>映射 <code>var_map</code> <code>varMap</code></li>
</ul>
<p><strong> 属性和方法 </strong></p>
<ul>
<li>私有(<em> <code>private</code> </em>)属性和方法命名应该以下划线 _ 开头;</li>
<li>受限(<em> <code>protected</code> </em>)属性和方法不需要下划线开头, 和公共变量保持一致.</li>
</ul>
<p>想要查阅更多关于 <code>private</code> 和 <code>protected</code> 的资料, 可以阅读本指南的<strong> 可见性 </strong>部分.</p>
<p><strong> 方法和函数参数 </strong></p>
<p>可缺省函数参数以 <code>opt_</code> 开头.</p>
<p>如果函数拥有不定参数, 那么应该添加一个名为 <code>var_args</code> 的参数作为最后一个参数. 如果不想在代码中使用 <code>var_args</code> , 也可以使用 <code>arguments</code> 伪数组.</p>
<p>可缺省参数和不定参数可以使用 <code>@param</code> 标记. 尽管是否这样做对解释器来说都可以接受, 但都使用是推荐的做法.</p>
<p><strong> 属性访问器 (Getters 和 Setters) </strong></p>
<p>EcmaScript 5 不推荐使用对象属性的 <code>getters</code> 和 <code>setters</code>.<br>然而, 如果你已经使用了它们, 请务必注意不要让 <code>getters</code> 去改变显著的对象属性状态.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 错误 -- 不要这样做.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123; get next() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.nextId++; &#125; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong> 函数访问器 </strong></p>
<p>也不对函数属性的 <code>getters</code> 和 <code>setters</code> 做要求. 然而, 如果已经使用来它们, 请将 <code>getters</code> 按 <code>getFoo()</code> 的形式命名, 而 <code>setters</code> 则必须命名成 <code>setFoo(value)</code> 的形式. (对布尔变量类型的 <code>getters</code> , <code>isFoo()</code> 形式的命名也可以接受, 而且这样同样也更加自然.)</p>
<p><strong> 命名空间 </strong></p>
<p>JavaScript 自身并没有对包和命名空间的支持.</p>
<p>全局变量的冲突非常难以调试, 而且当涉及多个项目集成时, 经常造成棘手的难题. 为了减少公共分享 JS 代码时可能出现的冲突问题, 我们应当遵循下列规范.</p>
<ul>
<li>在全局代码中使用伪命名空间</li>
</ul>
<p>在全局作用域中, <strong>始终</strong>将一个和库或项目关联的前缀标识名作为伪命名空间来使用.<br>如果你正在开发的项目名为”Porject Sloth”, 则一个合理的伪命名空间应该是 sloth.*.</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sloth = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">sloth.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一些类似 the Closure Library 和  Dojo toolkit 这样的 JS 库会提供一些高阶方法来声明命名空间.<br>使用统一的方法来声明命名空间.</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goog.provide(<span class="string">'sloth'</span>);</span><br><span class="line"></span><br><span class="line">sloth.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>尊重命名空间的所有权</li>
</ul>
<p>当选择在一个子命名空间下进行开发, 请确保父命名空间的所有者知道你正在进行的工作. 如果你正在开发一个为 sloth 创建 hats 的项目, 请确保开发 Sloth 的团队 了解你使用了 sloth.hats 作为命名空间.</p>
<ul>
<li>对外部代码和内部代码使用不同的命名空间</li>
</ul>
<p>“外部代码”指那些独立于你的代码体系可以独立编译的代码. 外部代码和内部代码的命名空间应该保持严格的隔离. 如果你使用来一个外部库, 其对象都处于 foo.hats.<em> 命名空间下, 你的内部代码就不该定义在 foo.hats.</em> 下定义任何东西, 因为当其他团队试图定义新的对象时就可能会与之发生冲突.</p>
<p>不要像这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo.require(<span class="string">'foo.hats'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 错误 -- 不要像这样写.</span><br><span class="line"> * @constructor</span><br><span class="line"> * @extends &#123;foo.hats.RoundHat&#125;</span><br><span class="line"> */</span></span><br><span class="line">foo.hats.BowlerHat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你需要在外部命名空间中定义新的 API, 那你应该显式地导出公共 API 函数, 并且仅仅只导出这些函数. 当你的内部代码需要调用这些 API 时, 可以直接通过内部命名来调用, 这是为了保持一致性, 并且可以让编译器能更好地进行优化.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo.provide(<span class="string">'googleyhats.BowlerHat'</span>);</span><br><span class="line"></span><br><span class="line">foo.require(<span class="string">'foo.hats'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @constructor</span><br><span class="line"> * @extends &#123;foo.hats.RoundHat&#125;</span><br><span class="line"> */</span></span><br><span class="line">googleyhats.BowlerHat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">goog.exportSymbol(<span class="string">'foo.hats.BowlerHat'</span>, googleyhats.BowlerHat);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用别名引用长名以增强可读性</li>
</ul>
<p>在局部作用域中可以使用别名来引用完整包名能够增强可读性.<br>局部作用域中别名的命名应和完整包名的最后一部分相匹配.</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span></span><br><span class="line">some.long.namespace.MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;some.long.namespace.MyClass&#125; a</span><br><span class="line"> */</span></span><br><span class="line">some.long.namespace.MyClass.staticHelper = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myapp.main = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> MyClass = some.long.namespace.MyClass;</span><br><span class="line">  <span class="keyword">var</span> staticHelper = some.long.namespace.MyClass.staticHelper;</span><br><span class="line">  staticHelper(<span class="keyword">new</span> MyClass());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不要在局部作用域中为命名空间创建别名.<br>仅仅当使用 <code>goog.scope</code> 时才能为命名空间创建别名.</p>
<p>不要像这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myapp.main = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> namespace = some.long.namespace;</span><br><span class="line">  namespace.MyClass.staticHelper(<span class="keyword">new</span> namespace.MyClass());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>避免访问一个别名的属性, 除非它是枚举类型.</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @enum &#123;string&#125; */</span></span><br><span class="line">some.long.namespace.Fruit = &#123;</span><br><span class="line">  APPLE: <span class="string">'a'</span>,</span><br><span class="line">  BANANA: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myapp.main = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Fruit = some.long.namespace.Fruit;</span><br><span class="line">  <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> Fruit.APPLE:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> Fruit.BANANA:</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不要像这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myapp.main = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> MyClass = some.long.namespace.MyClass;</span><br><span class="line">  MyClass.staticHelper(<span class="literal">null</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>千万不要在全局作用域中使用别名. 仅当处于函数块内才考虑使用它们.</p>
<ul>
<li>文件命名</li>
</ul>
<p>文件名应该全部使用小写字母, 避免在某些大小写敏感的平台造成混乱. 文件名应以.js作为后缀, 且文件名中不应该包含 - 或 <em> 以外的标点符号(优先使用 - ,接下来考虑使用 </em>).</p>
<h4 id="u81EA_u5B9A_u4E49_toString_28_29__u65B9_u6CD5"><a href="#u81EA_u5B9A_u4E49_toString_28_29__u65B9_u6CD5" class="headerlink" title="自定义 toString() 方法"></a>自定义 toString() 方法</h4><ul>
<li>应该总能调用成功, 且没有副作用.</li>
</ul>
<p>你可以通过自定义 toString() 方法来控制你的对象属性如何转化成字符串. 这没有什么问题, 但你需要确保你的方法做到 (1) 总是能调用成功且 (2) 不会造成副作用. 如果你的方法不能满足上述条件, 很容易会造成严重问题. 例如, 如果 toString() 调用一个包含 assert 的方法, 当调用失败时 assert 会尝试输出失败的对象名, 结果又会调用 toString().</p>
<h4 id="u5EF6_u8FDF_u521D_u59CB_u5316"><a href="#u5EF6_u8FDF_u521D_u59CB_u5316" class="headerlink" title="延迟初始化"></a>延迟初始化</h4><ul>
<li>没问题</li>
</ul>
<p>并不是总能在声明变量时初始化变量. 延迟初始化没有什么问题.</p>
<h4 id="u660E_u786E_u4F5C_u7528_u57DF"><a href="#u660E_u786E_u4F5C_u7528_u57DF" class="headerlink" title="明确作用域"></a>明确作用域</h4><ul>
<li>始终明确作用域</li>
</ul>
<p>任何时候都需要明确作用域 - 这样能够提高代码的可移植性和清晰度. 例如, 不应该依赖作用域链中的 window 对象. 有时你会希望在别的应用调用你的函数, 此时使用的 window 对象并非之前的窗口对象.</p>
<h4 id="u4EE3_u7801_u683C_u5F0F"><a href="#u4EE3_u7801_u683C_u5F0F" class="headerlink" title="代码格式"></a>代码格式</h4><blockquote>
<p>精神上遵从 C++ 格式规范, 做一些额外的补充:</p>
</blockquote>
<ul>
<li>大括号</li>
</ul>
<p>因为会隐式地插入分号, 所以无论括号是否在一行内闭合, 东欧应当将花括号和前面的代码放在一行中, 如下面的代码所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (something) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组和对象初始化</li>
</ul>
<p>如果放在一行比较合适, 单行的数组和对象初始化可以放在一行内完成:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// 前后皆无空格.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>&#125;;  <span class="comment">// 前后皆无空格.</span></span><br></pre></td></tr></table></figure>
<p>多行数组和对象的初始化应当缩进两个空格, 花括号单独成行, 类似代码块.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象初始化.</span></span><br><span class="line"><span class="keyword">var</span> inset = &#123;</span><br><span class="line">  top: <span class="number">10</span>,</span><br><span class="line">  right: <span class="number">20</span>,</span><br><span class="line">  bottom: <span class="number">15</span>,</span><br><span class="line">  left: <span class="number">12</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组初始化.</span></span><br><span class="line"><span class="keyword">this</span>.rows_ = [</span><br><span class="line">  <span class="string">'"Slartibartfast" &lt;fjordmaster@magrathea.com&gt;'</span>,</span><br><span class="line">  <span class="string">'"Zaphod Beeblebrox" &lt;theprez@universe.gov&gt;'</span>,</span><br><span class="line">  <span class="string">'"Ford Prefect" &lt;ford@theguide.com&gt;'</span>,</span><br><span class="line">  <span class="string">'"Arthur Dent" &lt;has.no.tea@gmail.com&gt;'</span>,</span><br><span class="line">  <span class="string">'"Marvin the Paranoid Android" &lt;marv@googlemail.com&gt;'</span>,</span><br><span class="line">  <span class="string">'the.mice@magrathea.com'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于方法调用.</span></span><br><span class="line">goog.dom.createDom(goog.dom.TagName.DIV, &#123;</span><br><span class="line">  id: <span class="string">'foo'</span>,</span><br><span class="line">  className: <span class="string">'some-css-class'</span>,</span><br><span class="line">  style: <span class="string">'display:none'</span></span><br><span class="line">&#125;, <span class="string">'Hello, world!'</span>);</span><br></pre></td></tr></table></figure>
<p>比较长的标识名或数值会使得对齐的初始化列表出现问题, 因此总是优先使用不对齐的初始化方式. 如下例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CORRECT_Object.prototype = &#123;</span><br><span class="line">  a: <span class="number">0</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  lengthyName: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不要这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WRONG_Object.prototype = &#123;</span><br><span class="line">  a          : <span class="number">0</span>,</span><br><span class="line">  b          : <span class="number">1</span>,</span><br><span class="line">  lengthyName: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数参数</li>
</ul>
<p>尽可能让所有的函数参数处于同一行, 但如果一行内宽度超过了 80 列的限制, 应当以更可读的方式换行处理. 为了节约空间, 你可以尽可能保持行宽接近 80 , 如果为来更好的可都性, 甚至可以让每个参数都单独一行. 既可以缩进4空格, 也可以与函数的圆括号对齐. 下面上参数换行处理的几种通用模式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4 空格缩进, 行宽保持在 80 左右. 适合函数名非常长的情况.</span></span><br><span class="line"><span class="comment">// 在函数重命名后无需重排缩进, 空间占用小.</span></span><br><span class="line">goog.foo.bar.doThingThatIsVeryDifficultToExplain = <span class="function"><span class="keyword">function</span>(<span class="params"></span><br><span class="line">    veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,</span><br><span class="line">    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 空格缩进, 单参数独立成行. 适合函数名非常长的情况.</span></span><br><span class="line"><span class="comment">// 在函数重命名后无需重排, 强调来每个参数.</span></span><br><span class="line">goog.foo.bar.doThingThatIsVeryDifficultToExplain = <span class="function"><span class="keyword">function</span>(<span class="params"></span><br><span class="line">    veryDescriptiveArgumentNumberOne,</span><br><span class="line">    veryDescriptiveArgumentTwo,</span><br><span class="line">    tableModelEventHandlerProxy,</span><br><span class="line">    artichokeDescriptorAdapterIterator</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小括号对齐缩进, 行宽保持在 80 左右.</span></span><br><span class="line"><span class="comment">// 可视的分组参数, 空间占用小.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,</span><br><span class="line">             tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小括号对齐, 单参数独立成行.</span></span><br><span class="line"><span class="comment">// 强调来每个单独的参数.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">veryDescriptiveArgumentNumberOne,</span><br><span class="line">             veryDescriptiveArgumentTwo,</span><br><span class="line">             tableModelEventHandlerProxy,</span><br><span class="line">             artichokeDescriptorAdapterIterator</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数自身是缩进的, 你可以自由选择到底是根据初始语句的缩进位置再缩进 4 格还是依据当前所处函数调用的起始位置来缩进. 下面几种缩进风格都是接受的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (veryLongFunctionNameA(</span><br><span class="line">        veryLongArgumentName) ||</span><br><span class="line">    veryLongFunctionNameB(</span><br><span class="line">    veryLongArgumentName)) &#123;</span><br><span class="line">  veryLongFunctionNameC(veryLongFunctionNameD(</span><br><span class="line">      veryLongFunctioNameE(</span><br><span class="line">          veryLongFunctionNameF)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传递匿名函数</li>
</ul>
<p>当传入参数的列表中包含匿名函数的声明时, 匿名函数的函数体应该相对于该函数调用从左侧缩进 2 格, 或者也可以选择从该匿名函数关键字的左侧处缩进 2 格. 这样可以让匿名函数的函数体更容易阅读(例如, 不需要把内容主题全部挤到屏幕右侧去).</p>
<p>示例代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prefix.something.reallyLongFunctionName(<span class="string">'whatever'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a1, a2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a1.equals(a2)) &#123;</span><br><span class="line">    someOtherLongFunctionName(a1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    andNowForSomethingCompletelyDifferent(a2.parrot);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = prefix.something.myExcellentMapFunction(</span><br><span class="line">    verboselyNamedCollectionOfItems,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> item.name;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>配合 goog.scope 使用别名</li>
</ul>
<p>当使用 the Closure Library 库时, 可以使用 <code>goog.scope</code> 来缩短对命名空间的引用.</p>
<p>每个文件内只能使用一次 <code>goog.scope</code> 调用, 并且始终放置在全局作用域中.</p>
<p>在打开 <code>goog.scope(fuchuntion() {</code> 代码块前, 需要保留且只保留一个空行, 上接 <code>goog.provide</code> 语句, <code>goog.require</code> 语句, 或者高层级的注释. 该代码块必须在文件最后一行处关闭, 即把 }); 放在文件末行处. 在代码块闭合处附加注释 <code>// goog.scope</code>, 并且将代码块与注释用分号和两个空格分隔.</p>
<p>类似 C++ 命名空间, 不要在 <code>goog.scope</code> 内缩进, 直接顶格开始.</p>
<p>只使用那些不会给其他对象使用的别名(例如多数构造函数, 枚举变量或者命名空间).</p>
<p>不要像这样写(参看更下面的代码来了解如何对构造函数使用别名):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goog.scope 内</span></span><br><span class="line"><span class="keyword">var</span> Button = goog.ui.Button;</span><br><span class="line"></span><br><span class="line">Button = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br><span class="line"><span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>
<p>别名应该和全局下调用的最后一个属性名相一致:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">goog.provide(<span class="string">'my.module.SomeType'</span>);</span><br><span class="line"></span><br><span class="line">goog.require(<span class="string">'goog.dom'</span>);</span><br><span class="line">goog.require(<span class="string">'goog.ui.Button'</span>);</span><br><span class="line"></span><br><span class="line">goog.scope(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> Button = goog.ui.Button;</span><br><span class="line"><span class="keyword">var</span> dom = goog.dom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias new types after the constructor declaration.</span></span><br><span class="line">my.module.SomeType = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br><span class="line"><span class="keyword">var</span> SomeType = my.module.SomeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare methods on the prototype as usual:</span></span><br><span class="line">SomeType.prototype.findButton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Button as aliased above.</span></span><br><span class="line">  <span class="keyword">this</span>.button = <span class="keyword">new</span> Button(dom.getElement(<span class="string">'my-button'</span>));</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;);  <span class="comment">// goog.scope</span></span><br></pre></td></tr></table></figure>
<ul>
<li>换行缩进</li>
</ul>
<p>除了对数组字面量, 对象字面量和匿名函数外, 换行都应该和上方同级表达式左对齐, 或则从父级表达式左侧处缩进 4 格(这里的父级和同级指的是括号嵌套的层级).</p>
<p>代码示例如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">someWonderfulHtml = <span class="string">''</span> +</span><br><span class="line">                    getEvenMoreHtml(someReallyInterestingValues, moreValues,</span><br><span class="line">                                    evenMoreParams, <span class="string">'a duck'</span>, <span class="literal">true</span>, <span class="number">72</span>,</span><br><span class="line">                                    slightlyMoreMonkeys(<span class="number">0xfff</span>)) +</span><br><span class="line">                    <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">thisIsAVeryLongVariableName =</span><br><span class="line">    hereIsAnEvenLongerOtherFunctionNameThatWillNotFitOnPrevLine();</span><br><span class="line"></span><br><span class="line">thisIsAVeryLongVariableName = siblingOne + siblingTwo + siblingThree +</span><br><span class="line">    siblingFour + siblingFive + siblingSix + siblingSeven +</span><br><span class="line">    moreSiblingExpressions + allAtTheSameIndentationLevel;</span><br><span class="line"></span><br><span class="line">thisIsAVeryLongVariableName = operandOne + operandTwo + operandThree +</span><br><span class="line">    operandFour + operandFive * (</span><br><span class="line">        aNestedChildExpression + shouldBeIndentedMore);</span><br><span class="line"></span><br><span class="line">someValue = <span class="keyword">this</span>.foo(</span><br><span class="line">    shortArg,</span><br><span class="line">    <span class="string">'非常非常非常非常长的字符串参数, 实际上这种情况经常出现.'</span>,</span><br><span class="line">    shorty2,</span><br><span class="line">    <span class="keyword">this</span>.bar());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (searchableCollection(allYourStuff).contains(theStuffYouWant) &amp;&amp;</span><br><span class="line">    !ambientNotification.isActive() &amp;&amp; (client.isAmbientSupported() ||</span><br><span class="line">                                        client.alwaysTryAmbientAnyways())) &#123;</span><br><span class="line">  ambientNotification.activate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>空行</li>
</ul>
<p>对逻辑相关的一段代码开新行来写, 如下例所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomethingTo(x);</span><br><span class="line">doSomethingElseTo(x);</span><br><span class="line">andThen(x);</span><br><span class="line"></span><br><span class="line">nowDoSomethingWith(y);</span><br><span class="line"></span><br><span class="line">andNowWith(z);</span><br></pre></td></tr></table></figure>
<ul>
<li>二元和三元操作符</li>
</ul>
<p>总是将操作符保留在前行. 其他方面的换行和缩进规则遵循指南中提到的其他规范即可. 这种事先约定的方式可以无需顾虑分号隐式插入造成的问题. 实际上, 分号不可能被隐式地插入到二元操作符之前, 但所有的代码都应该遵循一致的风格规范.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = a ? b : c;  <span class="comment">// All on one line if it will fit.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Indentation +4 is OK.</span></span><br><span class="line"><span class="keyword">var</span> y = a ?</span><br><span class="line">    longButSimpleOperandB : longButSimpleOperandC;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indenting to the line position of the first operand is also OK.</span></span><br><span class="line"><span class="keyword">var</span> z = a ?</span><br><span class="line">        moreComplicatedB :</span><br><span class="line">        moreComplicatedC;</span><br></pre></td></tr></table></figure>
<p>包括点操作符.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = foo.bar().</span><br><span class="line">    doSomething().</span><br><span class="line">    doSomethingElse();</span><br></pre></td></tr></table></figure>
<ul>
<li>小括号</li>
</ul>
<p>仅用于需要处. 成对使用, 一般情况下只在语法和语义要求处用括号.</p>
<p>在一元操作符(如 <code>delete</code>, <code>typeof</code> 和 <code>void</code>)或关键字(如 <code>return</code>, <code>throw</code>, <code>case</code>, <code>in</code> 或 <code>new</code>)后永远不要使用括号.</p>
<ul>
<li>字符串</li>
</ul>
<p>单引号’比双引号”好.</p>
<p>基于一致性的考虑, 优先使用单引号(‘)而不是双引号(“). 在创建包含 HTML 的字符串中这非常有用.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'This is some HTML'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>可见性(<code>private</code> 和 <code>protected</code> 字段)</li>
</ul>
<p>鼓励, 使用 JSDoc 中的 <code>@private</code> 和 <code>@protected</code> 来标注.</p>
<p>我们推荐使用 JSDoc 中的 <code>@private</code> 和 <code>@protected</code> 来标注类, 函数, 属性的可见级别.</p>
<p>使用编译器标识 –jscomp_warning=visibility 可以开启对代码违背可见性的警告. 可以参考 <a href="http://code.google.com/p/closure-compiler/wiki/Warnings" target="_blank" rel="external">Closure Compiler Warnings</a>.</p>
<p>私有全局变量和函数( <code>@private</code> )只能在同一文件中访问.</p>
<p>标注了 <code>@private</code> 的构造函数只能在同一文件中实例化或者访问公共静态属性. 私有构造函数还可以在同一文件的任意位置使用 <code>instanceof</code> 操作符使用公共静态属性.</p>
<p>全局变量, 全局函数和全局构造函数任何时候都不要用 <code>@protected</code> 标注.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 1.</span></span><br><span class="line"><span class="comment">// AA_PrivateClass_ 和 AA_init_ 可以访问因为它们是全局的并且在同一文件中.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @private</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span></span><br><span class="line">AA_PrivateClass_ = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @private */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AA_init_</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AA_PrivateClass_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AA_init_();</span><br></pre></td></tr></table></figure>
<p>标注了 <code>@private</code> 的私有属性在同一文件以及它所属类的静态方法和实例方法中都可以访问. 但处于不同文件的所属类的子类则无法访问和重载该属性.</p>
<p>标注了 <code>@protected</code> 的受限属性在同一文件, 以及包含这条属性的类及其任意子类的任意静态方法和实例方法中, 都可以访问.</p>
<p>注意这些语义与 C++ 和 Java 有所区别, 它们允许在同一文件中访问私有和受限属性, 而非限制在同一个类和类继承中. 另外, 不像 C++, 私有属性不允许被子类重载.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** @constructor */</span></span><br><span class="line">AA_PublicClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** @private */</span></span><br><span class="line">  <span class="keyword">this</span>.privateProp_ = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @protected */</span></span><br><span class="line">  <span class="keyword">this</span>.protectedProp = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @private */</span></span><br><span class="line">AA_PublicClass.staticPrivateProp_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @protected */</span></span><br><span class="line">AA_PublicClass.staticProtectedProp = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @private */</span></span><br><span class="line">AA_PublicClass.prototype.privateMethod_ = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @protected */</span></span><br><span class="line">AA_PublicClass.prototype.protectedMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 2.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @return &#123;number&#125; The number of ducks we've arranged in a row.</span><br><span class="line"> */</span></span><br><span class="line">AA_PublicClass.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合法访问这两条属性.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.privateProp_ + AA_PublicClass.staticPrivateProp_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 3.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @constructor</span><br><span class="line"> * @extends &#123;AA_PublicClass&#125;</span><br><span class="line"> */</span></span><br><span class="line">AA_SubClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合法访问受限静态属性.</span></span><br><span class="line">  AA_PublicClass.staticProtectedProp = <span class="keyword">this</span>.method();</span><br><span class="line">&#125;;</span><br><span class="line">goog.inherits(AA_SubClass, AA_PublicClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @return &#123;number&#125; The number of ducks we've arranged in a row.</span><br><span class="line"> */</span></span><br><span class="line">AA_SubClass.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合法访问静态实例属性.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.protectedProp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>请注意在 JS 中, 类型(比如 <code>AA_PrivateClass_</code>)和类型的构造函数的可见性是没有区别的. 并没有办法让一个类型共有而令其构造函数为私有(因为很容易对构造函数使用别名从而破坏私有检查).</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google JS 代码风格指南（1）]]></title>
    <link href="http://yoursite.com/2015/12/27/Google-JS-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2015/12/27/Google-JS-代码风格指南（1）/</id>
    <published>2015-12-27T06:05:11.651Z</published>
    <updated>2015-12-27T06:05:11.651Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title="JavaScript 代码风格指南"></a>JavaScript 代码风格指南</h2><p>这份指南列出了编写 JavaScript 时需要遵守的规范, 指明哪些应该<strong>提倡</strong>, 哪些应该<del>避免</del>.<br>本文基于 google 的规范翻译整理(JavaScript 是许多 Google 开源项目使用的主要客户端脚本语言).</p>
<h3 id="281_29"><a href="#281_29" class="headerlink" title="(1)"></a>(1)</h3><h3 id="JavaScript__u8BED_u8A00_u98CE_u683C_u89C4_u8303"><a href="#JavaScript__u8BED_u8A00_u98CE_u683C_u89C4_u8303" class="headerlink" title="JavaScript 语言风格规范"></a>JavaScript 语言风格规范</h3><h4 id="u53D8_u91CF"><a href="#u53D8_u91CF" class="headerlink" title="变量"></a>变量</h4><ul>
<li>声明变量务必使用 var 关键字.</li>
</ul>
<p>如果未能使用 <code>var</code> 来声明, 变量就会暴露在全局上下文中, 这样很可能会与已有变量冲突. 此外，如果没有声明，也难以确定变量的作用域, 变量既有可能出现在局部作用域中, 也可能轻易地泄漏到 <code>Document</code> 或 <code>Window</code> 作用域中, 因此务必使用 <code>var</code> 声明变量.</p>
<h4 id="u5E38_u91CF"><a href="#u5E38_u91CF" class="headerlink" title="常量"></a>常量</h4><ul>
<li>常量的规范命名应该使用这样的形式: <code>NAMES_LIKE_THIS</code>, 即使用大写字符, 并用下划线分隔单词.</li>
<li>也可以使用用 <code>@const</code> 标记来指明它是常量.</li>
<li>千万不要使用 <code>const</code> 关键词.</li>
</ul>
<p>对于基本类型的常量, 遵循命名规范即可.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* The number of seconds in a minute.</span><br><span class="line">* @type &#123;number&#125;</span><br><span class="line">*/</span></span><br><span class="line">goog.example.SECONDS_IN_A_MINUTE = <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>对于非基本类型, 使用 <code>@const</code> 标记.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* The number of seconds in each of the given units.</span><br><span class="line">* @type &#123;Object.&lt;number&gt;&#125;</span><br><span class="line">* @const</span><br><span class="line">*/</span></span><br><span class="line">goog.example.SECONDS_TABLE = &#123;</span><br><span class="line">minute: <span class="number">60</span>,</span><br><span class="line">  hour: <span class="number">60</span> * <span class="number">60</span>,</span><br><span class="line">  day: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>@const</code> 标记可以提醒编译器它属于常量.<br>至于关键词 <code>const</code>, 由于 IE 无法识别, 因此尽量不要使用.</p>
<h4 id="u5206_u53F7"><a href="#u5206_u53F7" class="headerlink" title="分号"></a>分号</h4><ul>
<li>语句结尾总是使用分号.</li>
</ul>
<p>依赖语句间的隐式分隔, 有时会造成微妙而难以调试的问题.<br>避免如此。<br>代码编写者自己应该更能清楚哪里是语句的起止.</p>
<p>在下述情况下, 漏掉分号尤其危险:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1.</span></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;  <span class="comment">// 这里没有使用分号.</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 包裹在函数中的一些初始化代码创建来一个局部作用域.</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2.  </span></span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  <span class="string">'i'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'j'</span>: <span class="number">2</span></span><br><span class="line">&#125;  <span class="comment">// 这里也没有使用分号.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试在 IE 上运行一段代码, 而在 firefox 上运行另外一段代码.</span></span><br><span class="line"><span class="comment">// 我知道你从来不会这样写代码, 但我们就不必纠结这个小问题了吧.</span></span><br><span class="line">[normalVersion, ffVersion][isIE]();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3.</span></span><br><span class="line"><span class="keyword">var</span> THINGS_TO_EAT = [apples, oysters, sprayOnCheese]  <span class="comment">// 这里也没有加分号.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件执行一段时髦的指令</span></span><br><span class="line">-<span class="number">1</span> == resultOfOperation() || die();</span><br></pre></td></tr></table></figure>
<p>这几段代码运行效果如何呢？</p>
<ol>
<li>例1会抛出 JavaScript 报错. 这段代码会解释成一个返回值为42的函数附带一个匿名函数作为参数而被调用, 返回值 42 无法以一个匿名函数为参数被”调用”, 从而导致报错.</li>
<li>例2中, 运行时很可能遇到 <code>‘no such property in undefined’</code> 错误, 原因是代码试图执行 <code>x[ffVersion]isIE()</code> .</li>
<li>例3中 <code>die()</code> 总会被调用并将返回值赋给 <code>THINGS_TO_EAT</code>. 因为一个数组减一的值始终为 <code>NaN</code>, 不会与任何变量相等, 哪怕 <code>resultOfOperation()</code> 返回 <code>NaN</code> 等式也不会成立.</li>
</ol>
<p>为何会这样呢?</p>
<p>JavaScript 要求语句以分号结尾, 除非当它觉得可以安全地推断语句的结束位置.<br>在上述几个例子中, 在语句中使用了函数声明, 对象或者数组字面量.<br>这种情况下,闭合的括号不足以作为语句结束的信号.<br>JavaScript 从来不会把接下来是<strong>中辍运算符</strong>或<strong>括号运算符</strong>的地方判断为语句结束位置.</p>
<p>这样会导致令人非常吃惊的后果, 因此请确保使用分号来结束语句.</p>
<h4 id="u5D4C_u5957_u51FD_u6570"><a href="#u5D4C_u5957_u51FD_u6570" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><ul>
<li>可以使用</li>
</ul>
<p>嵌套函数非常有用, 比如用于创建连续(continuations)或用于隐藏辅助函数. 随意使用它们就好.</p>
<h4 id="u4EE3_u7801_u5757_u5185_u58F0_u660E_u51FD_u6570"><a href="#u4EE3_u7801_u5757_u5185_u58F0_u660E_u51FD_u6570" class="headerlink" title="代码块内声明函数"></a>代码块内声明函数</h4><ul>
<li>不要在代码内声明函数</li>
</ul>
<p>不要这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管多数脚本引擎支持代码块内声明函数, 但这一特性并不属于 ECMAScript 规范 (参见 ECMA-262, 条款13与14). 更糟之处在于它们实现方式互不兼容, 与未来的 ECMAScript 建议也相违背. ECMAScript 只允许脚本或函数在顶级语句块中进行函数声明.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5F02_u5E38"><a href="#u5F02_u5E38" class="headerlink" title="异常"></a>异常</h4><ul>
<li>合理使用</li>
</ul>
<p>如果试图(使用应用程序开发框架等)写点复杂的东西, 基本上无可避免要使用异常. 尽管用就好.</p>
<h4 id="u81EA_u5B9A_u4E49_u5F02_u5E38"><a href="#u81EA_u5B9A_u4E49_u5F02_u5E38" class="headerlink" title="自定义异常"></a>自定义异常</h4><ul>
<li>合理使用</li>
</ul>
<p>如果不使用自定义异常, 函数返回的错误信息有时会非常复杂, 更不用说不够优雅了.<br>不太好的解决方案包括传递一个包含错误信息的引用类型, 或者总是返回一个可能包含错误类型的对象. 这些做法基本上都属于原始的 hack 异常处理技巧.<br>条件合适尽管利用自定义异常的语言特性就好.</p>
<h4 id="u6807_u51C6_u7279_u6027"><a href="#u6807_u51C6_u7279_u6027" class="headerlink" title="标准特性"></a>标准特性</h4><ul>
<li>总是优于非标准特性</li>
</ul>
<p>为了尽可能提高移植性和兼容性,应该总是优先使用标准特性而不是非标准特性(例如优先使用 <code>string.charAt(3)</code> 而不是 <code>string[3]</code> , 再比如说优先使用 DOM 原生方法去访问节点元素, 而非使用某个特定框架封装好的快捷引用).</p>
<h4 id="u5C01_u88C5_u57FA_u672C_u7C7B_u578B"><a href="#u5C01_u88C5_u57FA_u672C_u7C7B_u578B" class="headerlink" title="封装基本类型"></a>封装基本类型</h4><ul>
<li>一般情况下, 不要封装基本类型</li>
</ul>
<p>没有理由去封装基本类型, 而且这样做还存在一些风险:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);   </span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  alert(<span class="string">'hi'</span>);  </span><br><span class="line">  <span class="comment">// 运行结果会显示 'hi'.</span></span><br><span class="line">  <span class="comment">// 因为基本类型封装的实例调用 typeof 时会返回 "object", 在进行判断时又会被转换为布尔量类型 true .</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要这样写!</p>
<p>不过在需要进行类型转换时下面的写法是可行的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  alert(<span class="string">'hi'</span>);  <span class="comment">// 永远不会被显示.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="number">0</span>) == <span class="string">'boolean'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">0</span>) == <span class="string">'object'</span>;</span><br></pre></td></tr></table></figure>
<p>这种写法在需要将变量转换成数字,字符串或者布尔量类型时非常方便.</p>
<h4 id="u591A_u7EA7_u539F_u578B_u7ED3_u6784"><a href="#u591A_u7EA7_u539F_u578B_u7ED3_u6784" class="headerlink" title="多级原型结构"></a>多级原型结构</h4><ul>
<li>不推荐</li>
</ul>
<p>多级原型结构是 JavaScript 中实现继承的方式. 当你自定义了一个D类, 并且把另一个自定义的B类作为其原型, 就得到了一个多级原型结构.<br>这种原型结构会变得越来越复杂, 越来越难以维护.</p>
<p>基于上述原因, 可以考虑使用 the Closure 库 中的 <code>goog.inherits()</code> 或其他类似库函数.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  goog.base(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">goog.inherits(D, B);</span><br><span class="line"></span><br><span class="line">D.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u65B9_u6CD5_u548C_u6210_u5458_u53D8_u91CF_u5B9A_u4E49"><a href="#u65B9_u6CD5_u548C_u6210_u5458_u53D8_u91CF_u5B9A_u4E49" class="headerlink" title="方法和成员变量定义"></a>方法和成员变量定义</h4><ul>
<li><code>/** @constructor */ function SomeConstructor() { this.someProperty = 1; } Foo.prototype.someMethod = function() { ... };</code></li>
</ul>
<p>通过 <code>new</code> 有许多种方法为已经创建的对象添加方法和成员变量, 但推荐使用下面的方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而其他属性则推荐在构造器中初始化:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @constructor */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bar = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为何呢?</p>
<blockquote>
<p>现在的 JavaScript 引擎会基于对象的”形状”来优化, 向对象添加属性(包括覆写原型中设定的值)会改变对象的”形状”并导致性能降低.</p>
</blockquote>
<h4 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h4><ul>
<li>优先使用 <code>this.foo = null</code> 而非关键字 <code>delete</code></li>
</ul>
<p>使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.dispose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property_ = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而非:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.dispose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>.property_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在现代的 Javascript 引擎中, 改变对象属性个数的速度远远比为其重新赋值慢.<br>除非真有必要从对象的迭代列表中移除一个键, 或者想要改变 <code>if (key in obj)</code> 的结果, 否则应当尽量避免使用关键字 <code>delete</code></p>
<h4 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li>可以, 但务必谨慎.</li>
</ul>
<p>创建闭包的能力可能是 JS 最有用但却经常被忽略的特性了. 参阅 <a href="">a good description of how closures work</a>.</p>
<p>有一件事需要牢记, 闭包会保持一个指向它封闭作用域的指针. 因此在为 DOM 元素附加闭包时, 可能会产生循环引用,进而导致内存泄漏. 例如下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">element, a, b</span>) </span>&#123;</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* uses a and b */</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数闭包会保持对 <code>element</code>, <code>a</code> 和 <code>b</code> 的引用, 即使它从未使用 <code>element</code>. 而 <code>element</code> 也保持了对闭包的引用, 因此导致了循环引用, 无法被 GC 回收. 如果遇到这种情况, 可以按照下面代码结构优化一下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">element, a, b</span>) </span>&#123;</span><br><span class="line">  element.onclick = bar(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* uses a and b */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="eval_28_29"><a href="#eval_28_29" class="headerlink" title="eval()"></a>eval()</h4><ul>
<li>仅用于代码加载器和 REPL (交互式解释器) 中</li>
</ul>
<p><code>eval()</code> 会导致混乱的语义. 当 <code>eval()</code> 中包含用户输入内容, 使用时还可能造成安全隐患. 还可以通过更好, 更清晰, 更安全的方式编写代码, 因此一般情况下不要使用 <code>eval()</code>.</p>
<p>解析 RPC 响应时应该总是使用 JSON 并且使用 <code>JSON.parse()</code> 而非 <code>eval()</code> 来读取结果.</p>
<p>假设我们有一台服务器会返回类似下面的内容:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"Alice"</span></span>,</span><br><span class="line">  "<span class="attribute">id</span>": <span class="value"><span class="number">31502</span></span>,</span><br><span class="line">  "<span class="attribute">email</span>": <span class="value"><span class="string">"looking_glass@example.com"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>使用 eval() 的写法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userInfo = <span class="built_in">eval</span>(feed);</span><br><span class="line"><span class="keyword">var</span> email = userInfo[<span class="string">'email'</span>];</span><br></pre></td></tr></table></figure>
<p>feed 中可能包含的恶意 JS 代码会被 <code>eval()</code> 执行.</p>
<p>采用如下写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userInfo = <span class="built_in">JSON</span>.parse(feed);</span><br><span class="line"><span class="keyword">var</span> email = userInfo[<span class="string">'email'</span>];</span><br></pre></td></tr></table></figure>
<p>使用 <code>JSON.parse</code>, 无效的 JSON (也包括所有可执行的 JS 代码) 都会抛出异常.</p>
<h4 id="with_28_29__7B_7D"><a href="#with_28_29__7B_7D" class="headerlink" title="with() {}"></a><code>with() {}</code></h4><ul>
<li>不要使用</li>
</ul>
<p>使用 <code>with</code> 会导致程序的语义含混不清. 因为 <code>with</code> 添加过来的对象包含的属性很可能会与局部变量冲突, 进而彻底地改变程序的原有含义.</p>
<p>下面这段代码做了什么呢?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (foo) &#123;</span><br><span class="line">      <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回答是: 一切都有可能发生. 局部变量 <code>x</code> 可能会被 <code>foo</code> 对象中的属性覆盖. 它甚至可能会有一个 setter, 从而导致在赋值3时执行许多其他代码. 别用 <code>with</code>.</p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li>仅用于构造函数, 方法以及构造闭包.</li>
</ul>
<p><code>this</code> 的语义非常棘手. 有时它引用全局对象(多数情况下), 有时属于调用者的作用域(使用 <code>eval()</code> 时), 有时属于 DOM 树的某个节点(当为 HTML 属性绑定事件时), 有时属于某个新建的对象(使用构造函数时), 或者还有可能属于其他对象(当对函数使用 <code>call()</code> 或者 <code>apply()</code> 时).</p>
<p>由于在使用上很容易出错, 因此应当限制它在下列的情况下按需使用:</p>
<ul>
<li>构造函数中;</li>
<li>对象的方法中(包括构造闭包时);</li>
</ul>
<h4 id="for-in__u5FAA_u73AF"><a href="#for-in__u5FAA_u73AF" class="headerlink" title="for-in 循环"></a>for-in 循环</h4><ul>
<li>只用于 object/map/hash 的遍历</li>
</ul>
<p><code>for-in</code> 循环经常被错误地用于遍历数组元素. 然而这是非常容易导致错误的做法, 因为它并不会按 <code>0</code> 到 <code>length - 1</code> 的顺序去进行遍历, 而是会遍历这个对象包括其原型链上所有的键值. 下面是几个失败时的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    print(arr[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printArray([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// 这里没有问题.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">printArray(a);  <span class="comment">// 出错了.</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>);</span><br><span class="line">printArray(a);  <span class="comment">// 出错了.</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.buhu = <span class="string">'wine'</span>;</span><br><span class="line">printArray(a);  <span class="comment">// 又出错了.</span></span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">printArray(a);  <span class="comment">// 又出错了.</span></span><br></pre></td></tr></table></figure>
<p>遍历数组用最普通的 for 循环即可.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> l = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    print(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5173_u8054_u6570_u7EC4"><a href="#u5173_u8054_u6570_u7EC4" class="headerlink" title="关联数组"></a>关联数组</h4><ul>
<li>永远不要将 <code>Array</code> 作为 map/hash/associative 数组使用.</li>
</ul>
<p>不应该允许将 <code>Array</code> 作为关联数组使用, 换一个更准确的说法则是, 数组中不允许使用非整型作为索引值. 如果你需要一个 map/hash 类型, 请使用 <code>Object</code> 而非 <code>Array</code>, 因为在这种情况下, 你真正需要的也只是 <code>Object</code> 的特性而非 <code>Array</code> 的特性. <code>Array</code> 也只是扩展自 <code>Object</code> 类型 (就像 <code>Date</code>, <code>RegExp</code> 或者 <code>String</code> 一样).</p>
<h4 id="u591A_u884C_u5B57_u7B26_u4E32_u5B57_u9762_u91CF"><a href="#u591A_u884C_u5B57_u7B26_u4E32_u5B57_u9762_u91CF" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h4><ul>
<li>不要使用</li>
</ul>
<p>不要像这样写长字符串:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">'A rather long string of English text, an error message \</span><br><span class="line">                actually that just keeps going and going -- an error \</span><br><span class="line">                message to make the Energizer bunny blush (right through \</span><br><span class="line">                those Schwarzenegger shades)! Where was I? Oh yes, \</span><br><span class="line">                you\'ve got an error and all the extraneous whitespace is \</span><br><span class="line">                just gravy.  Have a nice day.'</span>;</span><br></pre></td></tr></table></figure>
<p>使用这种写法时, 每行开始处的空白字符无法在编译时被安全跳过; 而反斜划线后面的空白字符也常常会导致棘手的错误; 尽管多数脚本引擎支持这种写法, 但它并非 ECMAScript 的标准规范.</p>
<p>应当使用这种写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">'A rather long string of English text, an error message '</span> +</span><br><span class="line">  <span class="string">'actually that just keeps going and going -- an error '</span> +</span><br><span class="line">  <span class="string">'message to make the Energizer bunny blush (right through '</span> +</span><br><span class="line">  <span class="string">'those Schwarzenegger shades)! Where was I? Oh yes, '</span> +</span><br><span class="line">  <span class="string">'you\'ve got an error and all the extraneous whitespace is '</span> +</span><br><span class="line">  <span class="string">'just gravy.  Have a nice day.'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Array__u548C_Object__u5B57_u9762_u91CF"><a href="#Array__u548C_Object__u5B57_u9762_u91CF" class="headerlink" title="Array 和 Object 字面量"></a>Array 和 Object 字面量</h4><ul>
<li>可以使用</li>
</ul>
<p>使用 <code>Array</code> 和 <code>Object</code> 字面量而不是 <code>Array</code> 和 <code>Object</code> 构造器.</p>
<p><code>Array</code> 的构造函数很容易因为传参不当而造成错误.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为3.</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2, x3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为2.</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果x1是一个自然数, 则数组长度会变成 x1.</span></span><br><span class="line"><span class="comment">// 如果x1是一个数字, 但不是自然数, 这里则会抛出一个异常.</span></span><br><span class="line"><span class="comment">// 否则数组会拥有一个值为x1的元素.</span></span><br><span class="line"><span class="keyword">var</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为0.</span></span><br><span class="line"><span class="keyword">var</span> a4 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
<p>基于上述原因, 当有人重构代码将传入参数由两个变为一个时, 数组就可能变成非预期的长度.</p>
<p>为了避免出现这种奇怪的情况, 总是使用更加可读的数组字面量来声明数组.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [x1, x2, x3];</span><br><span class="line"><span class="keyword">var</span> a2 = [x1, x2];</span><br><span class="line"><span class="keyword">var</span> a3 = [x1];</span><br><span class="line"><span class="keyword">var</span> a4 = [];</span><br></pre></td></tr></table></figure>
<p>虽然 <code>Object</code> 构造器并不存在类似问题, 但鉴于可读性和一致性考虑, 最好也使用字面量来声明.</p>
<p>不要使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o2.a = <span class="number">0</span>;</span><br><span class="line">o2.b = <span class="number">1</span>;</span><br><span class="line">o2.c = <span class="number">2</span>;</span><br><span class="line">o2[<span class="string">'strange key'</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>应当写成:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">  a: <span class="number">0</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'strange key'</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u4FEE_u6539_u5185_u7F6E_u5BF9_u8C61_u7684_u539F_u578B"><a href="#u4FEE_u6539_u5185_u7F6E_u5BF9_u8C61_u7684_u539F_u578B" class="headerlink" title="修改内置对象的原型"></a>修改内置对象的原型</h4><ul>
<li>不要这样做</li>
</ul>
<p>尝试修改内建对象, 诸如 <code>Object.prototype</code> 或者 <code>Array.prototype</code> 的行为应该被严格禁止. 修改其他内建对象, 比如 <code>Function.prototype</code> 虽然没有那么危险, 但在生产环境中依然会带来调试问题, 应当尽量避免.</p>
<h4 id="IE_u4E0B_u7684_u6761_u4EF6_u6CE8_u91CA"><a href="#IE_u4E0B_u7684_u6761_u4EF6_u6CE8_u91CA" class="headerlink" title="IE下的条件注释"></a>IE下的条件注释</h4><ul>
<li>不要使用</li>
</ul>
<p>不要像这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*@cc_on if (@_jscript) &#123; return 2* @*/</span>  <span class="number">3</span>; <span class="comment">/*@ &#125; @*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 条件注释会干扰自动化工具的使用, 因为它们会在运行时改变 JavaScript 的语义树.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
