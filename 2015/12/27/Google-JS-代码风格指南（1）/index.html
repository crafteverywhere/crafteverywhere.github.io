<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description"/><title>Google JS 代码风格指南（1） | Zen</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Google JS 代码风格指南（1）</h1><a id="logo" href="/">Zen</a><p class="description">craft‘s note</p></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> Home</i></a><a href="/archives/"><i class="icon-archive"> Archive</i></a><a href="/atom.xml"><i class="icon-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">Google JS 代码风格指南（1）</h1><div class="post-meta">2015-12-27 | </div><span data-thread-key="2015/12/27/Google-JS-代码风格指南（1）/" class="ds-thread-count"></span><div class="post-content"><h2 id="JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357"><a href="#JavaScript__u4EE3_u7801_u98CE_u683C_u6307_u5357" class="headerlink" title="JavaScript 代码风格指南"></a>JavaScript 代码风格指南</h2><p>这份指南列出了编写 JavaScript 时需要遵守的规范, 指明哪些应该<strong>提倡</strong>, 哪些应该<del>避免</del>.<br>本文基于 google 的规范翻译整理(JavaScript 是许多 Google 开源项目使用的主要客户端脚本语言).</p>
<h3 id="281_29"><a href="#281_29" class="headerlink" title="(1)"></a>(1)</h3><h3 id="JavaScript__u8BED_u8A00_u98CE_u683C_u89C4_u8303"><a href="#JavaScript__u8BED_u8A00_u98CE_u683C_u89C4_u8303" class="headerlink" title="JavaScript 语言风格规范"></a>JavaScript 语言风格规范</h3><h4 id="u53D8_u91CF"><a href="#u53D8_u91CF" class="headerlink" title="变量"></a>变量</h4><ul>
<li>声明变量务必使用 var 关键字.</li>
</ul>
<p>如果未能使用 <code>var</code> 来声明, 变量就会暴露在全局上下文中, 这样很可能会与已有变量冲突. 此外，如果没有声明，也难以确定变量的作用域, 变量既有可能出现在局部作用域中, 也可能轻易地泄漏到 <code>Document</code> 或 <code>Window</code> 作用域中, 因此务必使用 <code>var</code> 声明变量.</p>
<h4 id="u5E38_u91CF"><a href="#u5E38_u91CF" class="headerlink" title="常量"></a>常量</h4><ul>
<li>常量的规范命名应该使用这样的形式: <code>NAMES_LIKE_THIS</code>, 即使用大写字符, 并用下划线分隔单词.</li>
<li>也可以使用用 <code>@const</code> 标记来指明它是常量.</li>
<li>千万不要使用 <code>const</code> 关键词.</li>
</ul>
<p>对于基本类型的常量, 遵循命名规范即可.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* The number of seconds in a minute.</span><br><span class="line">* @type &#123;number&#125;</span><br><span class="line">*/</span></span><br><span class="line">goog.example.SECONDS_IN_A_MINUTE = <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>对于非基本类型, 使用 <code>@const</code> 标记.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* The number of seconds in each of the given units.</span><br><span class="line">* @type &#123;Object.&lt;number&gt;&#125;</span><br><span class="line">* @const</span><br><span class="line">*/</span></span><br><span class="line">goog.example.SECONDS_TABLE = &#123;</span><br><span class="line">minute: <span class="number">60</span>,</span><br><span class="line">  hour: <span class="number">60</span> * <span class="number">60</span>,</span><br><span class="line">  day: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>@const</code> 标记可以提醒编译器它属于常量.<br>至于关键词 <code>const</code>, 由于 IE 无法识别, 因此尽量不要使用.</p>
<h4 id="u5206_u53F7"><a href="#u5206_u53F7" class="headerlink" title="分号"></a>分号</h4><ul>
<li>语句结尾总是使用分号.</li>
</ul>
<p>依赖语句间的隐式分隔, 有时会造成微妙而难以调试的问题.<br>避免如此。<br>代码编写者自己应该更能清楚哪里是语句的起止.</p>
<p>在下述情况下, 漏掉分号尤其危险:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1.</span></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;  <span class="comment">// 这里没有使用分号.</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 包裹在函数中的一些初始化代码创建来一个局部作用域.</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2.  </span></span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  <span class="string">'i'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'j'</span>: <span class="number">2</span></span><br><span class="line">&#125;  <span class="comment">// 这里也没有使用分号.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试在 IE 上运行一段代码, 而在 firefox 上运行另外一段代码.</span></span><br><span class="line"><span class="comment">// 我知道你从来不会这样写代码, 但我们就不必纠结这个小问题了吧.</span></span><br><span class="line">[normalVersion, ffVersion][isIE]();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3.</span></span><br><span class="line"><span class="keyword">var</span> THINGS_TO_EAT = [apples, oysters, sprayOnCheese]  <span class="comment">// 这里也没有加分号.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件执行一段时髦的指令</span></span><br><span class="line">-<span class="number">1</span> == resultOfOperation() || die();</span><br></pre></td></tr></table></figure>
<p>这几段代码运行效果如何呢？</p>
<ol>
<li>例1会抛出 JavaScript 报错. 这段代码会解释成一个返回值为42的函数附带一个匿名函数作为参数而被调用, 返回值 42 无法以一个匿名函数为参数被”调用”, 从而导致报错.</li>
<li>例2中, 运行时很可能遇到 <code>‘no such property in undefined’</code> 错误, 原因是代码试图执行 <code>x[ffVersion]isIE()</code> .</li>
<li>例3中 <code>die()</code> 总会被调用并将返回值赋给 <code>THINGS_TO_EAT</code>. 因为一个数组减一的值始终为 <code>NaN</code>, 不会与任何变量相等, 哪怕 <code>resultOfOperation()</code> 返回 <code>NaN</code> 等式也不会成立.</li>
</ol>
<p>为何会这样呢?</p>
<p>JavaScript 要求语句以分号结尾, 除非当它觉得可以安全地推断语句的结束位置.<br>在上述几个例子中, 在语句中使用了函数声明, 对象或者数组字面量.<br>这种情况下,闭合的括号不足以作为语句结束的信号.<br>JavaScript 从来不会把接下来是<strong>中辍运算符</strong>或<strong>括号运算符</strong>的地方判断为语句结束位置.</p>
<p>这样会导致令人非常吃惊的后果, 因此请确保使用分号来结束语句.</p>
<h4 id="u5D4C_u5957_u51FD_u6570"><a href="#u5D4C_u5957_u51FD_u6570" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><ul>
<li>可以使用</li>
</ul>
<p>嵌套函数非常有用, 比如用于创建连续(continuations)或用于隐藏辅助函数. 随意使用它们就好.</p>
<h4 id="u4EE3_u7801_u5757_u5185_u58F0_u660E_u51FD_u6570"><a href="#u4EE3_u7801_u5757_u5185_u58F0_u660E_u51FD_u6570" class="headerlink" title="代码块内声明函数"></a>代码块内声明函数</h4><ul>
<li>不要在代码内声明函数</li>
</ul>
<p>不要这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管多数脚本引擎支持代码块内声明函数, 但这一特性并不属于 ECMAScript 规范 (参见 ECMA-262, 条款13与14). 更糟之处在于它们实现方式互不兼容, 与未来的 ECMAScript 建议也相违背. ECMAScript 只允许脚本或函数在顶级语句块中进行函数声明.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5F02_u5E38"><a href="#u5F02_u5E38" class="headerlink" title="异常"></a>异常</h4><ul>
<li>合理使用</li>
</ul>
<p>如果试图(使用应用程序开发框架等)写点复杂的东西, 基本上无可避免要使用异常. 尽管用就好.</p>
<h4 id="u81EA_u5B9A_u4E49_u5F02_u5E38"><a href="#u81EA_u5B9A_u4E49_u5F02_u5E38" class="headerlink" title="自定义异常"></a>自定义异常</h4><ul>
<li>合理使用</li>
</ul>
<p>如果不使用自定义异常, 函数返回的错误信息有时会非常复杂, 更不用说不够优雅了.<br>不太好的解决方案包括传递一个包含错误信息的引用类型, 或者总是返回一个可能包含错误类型的对象. 这些做法基本上都属于原始的 hack 异常处理技巧.<br>条件合适尽管利用自定义异常的语言特性就好.</p>
<h4 id="u6807_u51C6_u7279_u6027"><a href="#u6807_u51C6_u7279_u6027" class="headerlink" title="标准特性"></a>标准特性</h4><ul>
<li>总是优于非标准特性</li>
</ul>
<p>为了尽可能提高移植性和兼容性,应该总是优先使用标准特性而不是非标准特性(例如优先使用 <code>string.charAt(3)</code> 而不是 <code>string[3]</code> , 再比如说优先使用 DOM 原生方法去访问节点元素, 而非使用某个特定框架封装好的快捷引用).</p>
<h4 id="u5C01_u88C5_u57FA_u672C_u7C7B_u578B"><a href="#u5C01_u88C5_u57FA_u672C_u7C7B_u578B" class="headerlink" title="封装基本类型"></a>封装基本类型</h4><ul>
<li>一般情况下, 不要封装基本类型</li>
</ul>
<p>没有理由去封装基本类型, 而且这样做还存在一些风险:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);   </span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  alert(<span class="string">'hi'</span>);  </span><br><span class="line">  <span class="comment">// 运行结果会显示 'hi'.</span></span><br><span class="line">  <span class="comment">// 因为基本类型封装的实例调用 typeof 时会返回 "object", 在进行判断时又会被转换为布尔量类型 true .</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要这样写!</p>
<p>不过在需要进行类型转换时下面的写法是可行的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  alert(<span class="string">'hi'</span>);  <span class="comment">// 永远不会被显示.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="number">0</span>) == <span class="string">'boolean'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">0</span>) == <span class="string">'object'</span>;</span><br></pre></td></tr></table></figure>
<p>这种写法在需要将变量转换成数字,字符串或者布尔量类型时非常方便.</p>
<h4 id="u591A_u7EA7_u539F_u578B_u7ED3_u6784"><a href="#u591A_u7EA7_u539F_u578B_u7ED3_u6784" class="headerlink" title="多级原型结构"></a>多级原型结构</h4><ul>
<li>不推荐</li>
</ul>
<p>多级原型结构是 JavaScript 中实现继承的方式. 当你自定义了一个D类, 并且把另一个自定义的B类作为其原型, 就得到了一个多级原型结构.<br>这种原型结构会变得越来越复杂, 越来越难以维护.</p>
<p>基于上述原因, 可以考虑使用 the Closure 库 中的 <code>goog.inherits()</code> 或其他类似库函数.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  goog.base(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">goog.inherits(D, B);</span><br><span class="line"></span><br><span class="line">D.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u65B9_u6CD5_u548C_u6210_u5458_u53D8_u91CF_u5B9A_u4E49"><a href="#u65B9_u6CD5_u548C_u6210_u5458_u53D8_u91CF_u5B9A_u4E49" class="headerlink" title="方法和成员变量定义"></a>方法和成员变量定义</h4><ul>
<li><code>/** @constructor */ function SomeConstructor() { this.someProperty = 1; } Foo.prototype.someMethod = function() { ... };</code></li>
</ul>
<p>通过 <code>new</code> 有许多种方法为已经创建的对象添加方法和成员变量, 但推荐使用下面的方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而其他属性则推荐在构造器中初始化:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @constructor */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bar = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为何呢?</p>
<blockquote>
<p>现在的 JavaScript 引擎会基于对象的”形状”来优化, 向对象添加属性(包括覆写原型中设定的值)会改变对象的”形状”并导致性能降低.</p>
</blockquote>
<h4 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h4><ul>
<li>优先使用 <code>this.foo = null</code> 而非关键字 <code>delete</code></li>
</ul>
<p>使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.dispose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property_ = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而非:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.dispose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>.property_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在现代的 Javascript 引擎中, 改变对象属性个数的速度远远比为其重新赋值慢.<br>除非真有必要从对象的迭代列表中移除一个键, 或者想要改变 <code>if (key in obj)</code> 的结果, 否则应当尽量避免使用关键字 <code>delete</code></p>
<h4 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li>可以, 但务必谨慎.</li>
</ul>
<p>创建闭包的能力可能是 JS 最有用但却经常被忽略的特性了. 参阅 <a href="">a good description of how closures work</a>.</p>
<p>有一件事需要牢记, 闭包会保持一个指向它封闭作用域的指针. 因此在为 DOM 元素附加闭包时, 可能会产生循环引用,进而导致内存泄漏. 例如下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">element, a, b</span>) </span>&#123;</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* uses a and b */</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数闭包会保持对 <code>element</code>, <code>a</code> 和 <code>b</code> 的引用, 即使它从未使用 <code>element</code>. 而 <code>element</code> 也保持了对闭包的引用, 因此导致了循环引用, 无法被 GC 回收. 如果遇到这种情况, 可以按照下面代码结构优化一下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">element, a, b</span>) </span>&#123;</span><br><span class="line">  element.onclick = bar(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* uses a and b */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="eval_28_29"><a href="#eval_28_29" class="headerlink" title="eval()"></a>eval()</h4><ul>
<li>仅用于代码加载器和 REPL (交互式解释器) 中</li>
</ul>
<p><code>eval()</code> 会导致混乱的语义. 当 <code>eval()</code> 中包含用户输入内容, 使用时还可能造成安全隐患. 还可以通过更好, 更清晰, 更安全的方式编写代码, 因此一般情况下不要使用 <code>eval()</code>.</p>
<p>解析 RPC 响应时应该总是使用 JSON 并且使用 <code>JSON.parse()</code> 而非 <code>eval()</code> 来读取结果.</p>
<p>假设我们有一台服务器会返回类似下面的内容:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"Alice"</span></span>,</span><br><span class="line">  "<span class="attribute">id</span>": <span class="value"><span class="number">31502</span></span>,</span><br><span class="line">  "<span class="attribute">email</span>": <span class="value"><span class="string">"looking_glass@example.com"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>使用 eval() 的写法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userInfo = <span class="built_in">eval</span>(feed);</span><br><span class="line"><span class="keyword">var</span> email = userInfo[<span class="string">'email'</span>];</span><br></pre></td></tr></table></figure>
<p>feed 中可能包含的恶意 JS 代码会被 <code>eval()</code> 执行.</p>
<p>采用如下写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userInfo = <span class="built_in">JSON</span>.parse(feed);</span><br><span class="line"><span class="keyword">var</span> email = userInfo[<span class="string">'email'</span>];</span><br></pre></td></tr></table></figure>
<p>使用 <code>JSON.parse</code>, 无效的 JSON (也包括所有可执行的 JS 代码) 都会抛出异常.</p>
<h4 id="with_28_29__7B_7D"><a href="#with_28_29__7B_7D" class="headerlink" title="with() {}"></a><code>with() {}</code></h4><ul>
<li>不要使用</li>
</ul>
<p>使用 <code>with</code> 会导致程序的语义含混不清. 因为 <code>with</code> 添加过来的对象包含的属性很可能会与局部变量冲突, 进而彻底地改变程序的原有含义.</p>
<p>下面这段代码做了什么呢?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (foo) &#123;</span><br><span class="line">      <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回答是: 一切都有可能发生. 局部变量 <code>x</code> 可能会被 <code>foo</code> 对象中的属性覆盖. 它甚至可能会有一个 setter, 从而导致在赋值3时执行许多其他代码. 别用 <code>with</code>.</p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li>仅用于构造函数, 方法以及构造闭包.</li>
</ul>
<p><code>this</code> 的语义非常棘手. 有时它引用全局对象(多数情况下), 有时属于调用者的作用域(使用 <code>eval()</code> 时), 有时属于 DOM 树的某个节点(当为 HTML 属性绑定事件时), 有时属于某个新建的对象(使用构造函数时), 或者还有可能属于其他对象(当对函数使用 <code>call()</code> 或者 <code>apply()</code> 时).</p>
<p>由于在使用上很容易出错, 因此应当限制它在下列的情况下按需使用:</p>
<ul>
<li>构造函数中;</li>
<li>对象的方法中(包括构造闭包时);</li>
</ul>
<h4 id="for-in__u5FAA_u73AF"><a href="#for-in__u5FAA_u73AF" class="headerlink" title="for-in 循环"></a>for-in 循环</h4><ul>
<li>只用于 object/map/hash 的遍历</li>
</ul>
<p><code>for-in</code> 循环经常被错误地用于遍历数组元素. 然而这是非常容易导致错误的做法, 因为它并不会按 <code>0</code> 到 <code>length - 1</code> 的顺序去进行遍历, 而是会遍历这个对象包括其原型链上所有的键值. 下面是几个失败时的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    print(arr[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printArray([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// 这里没有问题.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">printArray(a);  <span class="comment">// 出错了.</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>);</span><br><span class="line">printArray(a);  <span class="comment">// 出错了.</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.buhu = <span class="string">'wine'</span>;</span><br><span class="line">printArray(a);  <span class="comment">// 又出错了.</span></span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">printArray(a);  <span class="comment">// 又出错了.</span></span><br></pre></td></tr></table></figure>
<p>遍历数组用最普通的 for 循环即可.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> l = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    print(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5173_u8054_u6570_u7EC4"><a href="#u5173_u8054_u6570_u7EC4" class="headerlink" title="关联数组"></a>关联数组</h4><ul>
<li>永远不要将 <code>Array</code> 作为 map/hash/associative 数组使用.</li>
</ul>
<p>不应该允许将 <code>Array</code> 作为关联数组使用, 换一个更准确的说法则是, 数组中不允许使用非整型作为索引值. 如果你需要一个 map/hash 类型, 请使用 <code>Object</code> 而非 <code>Array</code>, 因为在这种情况下, 你真正需要的也只是 <code>Object</code> 的特性而非 <code>Array</code> 的特性. <code>Array</code> 也只是扩展自 <code>Object</code> 类型 (就像 <code>Date</code>, <code>RegExp</code> 或者 <code>String</code> 一样).</p>
<h4 id="u591A_u884C_u5B57_u7B26_u4E32_u5B57_u9762_u91CF"><a href="#u591A_u884C_u5B57_u7B26_u4E32_u5B57_u9762_u91CF" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h4><ul>
<li>不要使用</li>
</ul>
<p>不要像这样写长字符串:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">'A rather long string of English text, an error message \</span><br><span class="line">                actually that just keeps going and going -- an error \</span><br><span class="line">                message to make the Energizer bunny blush (right through \</span><br><span class="line">                those Schwarzenegger shades)! Where was I? Oh yes, \</span><br><span class="line">                you\'ve got an error and all the extraneous whitespace is \</span><br><span class="line">                just gravy.  Have a nice day.'</span>;</span><br></pre></td></tr></table></figure>
<p>使用这种写法时, 每行开始处的空白字符无法在编译时被安全跳过; 而反斜划线后面的空白字符也常常会导致棘手的错误; 尽管多数脚本引擎支持这种写法, 但它并非 ECMAScript 的标准规范.</p>
<p>应当使用这种写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">'A rather long string of English text, an error message '</span> +</span><br><span class="line">  <span class="string">'actually that just keeps going and going -- an error '</span> +</span><br><span class="line">  <span class="string">'message to make the Energizer bunny blush (right through '</span> +</span><br><span class="line">  <span class="string">'those Schwarzenegger shades)! Where was I? Oh yes, '</span> +</span><br><span class="line">  <span class="string">'you\'ve got an error and all the extraneous whitespace is '</span> +</span><br><span class="line">  <span class="string">'just gravy.  Have a nice day.'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Array__u548C_Object__u5B57_u9762_u91CF"><a href="#Array__u548C_Object__u5B57_u9762_u91CF" class="headerlink" title="Array 和 Object 字面量"></a>Array 和 Object 字面量</h4><ul>
<li>可以使用</li>
</ul>
<p>使用 <code>Array</code> 和 <code>Object</code> 字面量而不是 <code>Array</code> 和 <code>Object</code> 构造器.</p>
<p><code>Array</code> 的构造函数很容易因为传参不当而造成错误.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为3.</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2, x3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为2.</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果x1是一个自然数, 则数组长度会变成 x1.</span></span><br><span class="line"><span class="comment">// 如果x1是一个数字, 但不是自然数, 这里则会抛出一个异常.</span></span><br><span class="line"><span class="comment">// 否则数组会拥有一个值为x1的元素.</span></span><br><span class="line"><span class="keyword">var</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为0.</span></span><br><span class="line"><span class="keyword">var</span> a4 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
<p>基于上述原因, 当有人重构代码将传入参数由两个变为一个时, 数组就可能变成非预期的长度.</p>
<p>为了避免出现这种奇怪的情况, 总是使用更加可读的数组字面量来声明数组.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [x1, x2, x3];</span><br><span class="line"><span class="keyword">var</span> a2 = [x1, x2];</span><br><span class="line"><span class="keyword">var</span> a3 = [x1];</span><br><span class="line"><span class="keyword">var</span> a4 = [];</span><br></pre></td></tr></table></figure>
<p>虽然 <code>Object</code> 构造器并不存在类似问题, 但鉴于可读性和一致性考虑, 最好也使用字面量来声明.</p>
<p>不要使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o2.a = <span class="number">0</span>;</span><br><span class="line">o2.b = <span class="number">1</span>;</span><br><span class="line">o2.c = <span class="number">2</span>;</span><br><span class="line">o2[<span class="string">'strange key'</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>应当写成:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">  a: <span class="number">0</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'strange key'</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u4FEE_u6539_u5185_u7F6E_u5BF9_u8C61_u7684_u539F_u578B"><a href="#u4FEE_u6539_u5185_u7F6E_u5BF9_u8C61_u7684_u539F_u578B" class="headerlink" title="修改内置对象的原型"></a>修改内置对象的原型</h4><ul>
<li>不要这样做</li>
</ul>
<p>尝试修改内建对象, 诸如 <code>Object.prototype</code> 或者 <code>Array.prototype</code> 的行为应该被严格禁止. 修改其他内建对象, 比如 <code>Function.prototype</code> 虽然没有那么危险, 但在生产环境中依然会带来调试问题, 应当尽量避免.</p>
<h4 id="IE_u4E0B_u7684_u6761_u4EF6_u6CE8_u91CA"><a href="#IE_u4E0B_u7684_u6761_u4EF6_u6CE8_u91CA" class="headerlink" title="IE下的条件注释"></a>IE下的条件注释</h4><ul>
<li>不要使用</li>
</ul>
<p>不要像这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*@cc_on if (@_jscript) &#123; return 2* @*/</span>  <span class="number">3</span>; <span class="comment">/*@ &#125; @*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 条件注释会干扰自动化工具的使用, 因为它们会在运行时改变 JavaScript 的语义树.</p>
</div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a href="/2015/12/27/Google-JS-代码风格指南（2）/" class="pre"><i class="icon-previous">Google JS 代码风格指南（2）</i></a></div><div data-thread-key="2015/12/27/Google-JS-代码风格指南（1）/" data-title="Google JS 代码风格指南（1）" data-url="http://yoursite.com/2015/12/27/Google-JS-代码风格指南（1）/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2015/12/27/Google-JS-代码风格指南（1）/" data-title="Google JS 代码风格指南（1）" data-url="http://yoursite.com/2015/12/27/Google-JS-代码风格指南（1）/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title">Categories</div></div><div class="widget"><div class="widget-title">Tags</div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a></div></div><div class="widget"><div class="widget-title">Recent</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/12/29/使用nginx和nginx-rtmp搭建流媒体服务器/">使用 nginx 和 nginx-rtmp 搭建流媒体服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/27/Google-JS-代码风格指南（5）/">Google JS 代码风格指南（5）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/27/Google-JS-代码风格指南（4）/">Google JS 代码风格指南（4）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/27/Google-JS-代码风格指南（3）/">Google JS 代码风格指南（3）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/27/Google-JS-代码风格指南（2）/">Google JS 代码风格指南（2）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/27/Google-JS-代码风格指南（1）/">Google JS 代码风格指南（1）</a></li></ul></div><div class="widget"><div class="comments-title">Recent Comments</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">Blogroll</div><ul></ul><a href="https://www.zhihu.com/people/craftman" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://www.douban.com/people/craftman/" title="豆瓣" target="_blank">豆瓣</a></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">Zen.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>var duoshuoQuery = {short_name:'crafteverywhere'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></body></html>